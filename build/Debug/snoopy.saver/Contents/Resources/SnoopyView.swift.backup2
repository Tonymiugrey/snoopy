//  SnoopyScreenSaverView.swift

import AVFoundation
import AVKit
import ScreenSaver
import SpriteKit

// Define ViewStateType enum
enum ViewStateType {
    case initial
    case playingAS
    case transitioningToHalftoneHide  // Playing TM_Hide
    case playingSTHide
    case playingRPH
    case playingBP  // Includes Loop
    case playingAPIntro
    case playingAPLoop
    case playingAPOutro
    case playingCM
    case decidingNextHalftoneAction  // After BP loop or AP/CM finishes
    case transitioningToASReveal  // Playing ST_Reveal
    case playingTMReveal
    case playingSSIntro  // Similar states for SS Loop, Outro etc.
    // ... add other states as needed
}

@objc(SnoopyScreenSaverView)
class SnoopyScreenSaverView: ScreenSaverView {
    // Â∏∏Èáè
    private let scale: CGFloat = 720.0 / 1080.0
    private let offside: CGFloat = 180.0 / 1080.0
    
    // --- State Management Properties ---
    private var allClips: [SnoopyClip] = []
    private var currentClipsQueue: [SnoopyClip] = []
    private var currentClipIndex: Int = 0
    private var currentNode: String?  // e.g., "BP001"
    private var currentStateType: ViewStateType = .initial
    private var currentRepeatCount: Int = 0  // For handling loops manually
    private var isMasking: Bool = false  // Flag to indicate mask transition is active
    // --- Ê∑ªÂä†Áä∂ÊÄÅÂèòÈáè ---
    private var bpCycleCount: Int = 0
    private var lastTransitionNumber: String?  // Stores the number (e.g., "001") of the last ST/TM Reveal
    private var nextAfterAS: [SnoopyClip] = []  // Stores clips to play after AS finishes
    private var isFirstASPlayback: Bool = true  // Ê†áËÆ∞ÊòØÂê¶‰∏∫ÂàùÊ¨°ASÊí≠Êîæ
    // --- ÁªìÊùüÊ∑ªÂä† ---
    
    // --- Player and Nodes ---
    private var queuePlayer: AVQueuePlayer?
    private var playerItem: AVPlayerItem?  // Keep track of the current item for notifications
    private var overlayPlayer: AVQueuePlayer?  // Player for VI/WE overlays
    private var overlayPlayerItem: AVPlayerItem?  // Track overlay item
    private var overlayRepeatCount: Int = 0  // For overlay loops
    
    // --- AS/SS Independent Player System ---
    private var asPlayer: AVPlayer?  // Independent player for AS/SS content
    private var asPlayerItem: AVPlayerItem?  // Track AS/SS player item
    private var asVideoNode: SKVideoNode?  // Video node for AS/SS content in cropNode
    
    // --- Masking Properties ---
    private var cropNode: SKCropNode?
    
    // --- HEIC Sequence Player Properties ---
    private var heicSequencePlayer: HEICSequencePlayer?
    private var tmMaskSpriteNode: SKSpriteNode?
    
    private var skView: SKView?
    private var scene: SKScene?
    private var backgroundColorNode: SKSpriteNode?
    private var halftoneNode: SKSpriteNode?
    private var backgroundImageNode: SKSpriteNode?  // IS image
    private var videoNode: SKVideoNode?
    private var overlayNode: SKVideoNode?  // Node for VI/WE overlays
    
    private let colors: [NSColor] = [
        NSColor(red: 50.0 / 255.0, green: 60.0 / 255.0, blue: 47.0 / 255.0, alpha: 1.0),
        NSColor(red: 5.0 / 255.0, green: 168.0 / 255.0, blue: 157.0 / 255.0, alpha: 1.0),
        NSColor(red: 65.0 / 255.0, green: 176.0 / 255.0, blue: 246.0 / 255.0, alpha: 1.0),
        NSColor(red: 238.0 / 255.0, green: 95.0 / 255.0, blue: 167.0 / 255.0, alpha: 1.0),
        NSColor.black,
    ]
    
    private var backgroundImages: [String] = []
    
    // MARK: - Initialization and Setup
    
    override init?(frame: NSRect, isPreview: Bool) {
        super.init(frame: frame, isPreview: isPreview)
        
        animationTimeInterval = 1.0 / 30.0
        
        // Âú®Sonoma‰∏äÂª∂ËøüÂàùÂßãÂåñÔºåÈÅøÂÖçlegacyScreenSaverÈóÆÈ¢ò
        if #available(macOS 14.0, *) {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.setupView()
            }
        } else {
            setupView()
        }
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        
        animationTimeInterval = 1.0 / 30.0
        
        // Âú®Sonoma‰∏äÂª∂ËøüÂàùÂßãÂåñÔºåÈÅøÂÖçlegacyScreenSaverÈóÆÈ¢ò
        if #available(macOS 14.0, *) {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.setupView()
            }
        } else {
            setupView()
        }
    }
    
    private func setupView() {
        loadBackgroundImages()  // Load IS names
        
        // Setup SKView and Scene first
        setupScene()
        
        // Asynchronously load clips and then start
        Task {
            do {
                print("Loading clips...")
                // Use SnoopyClip.loadClips() to load clips
                self.allClips = try await SnoopyClip.loadClips()
                print("Clips loaded: \(self.allClips.count)")
                guard !self.allClips.isEmpty else {
                    print("No clips loaded, cannot start.")
                    // Handle error state - maybe show a static image or message
                    return
                }
                // Setup player *after* clips are loaded
                setupPlayer()
                // Set initial state and start playback
                setupInitialStateAndPlay()
            } catch {
                print("Error loading clips: \(error)")
                // Handle error state
            }
        }
        
        // Notifications remain the same
        setNotifications()
    }
    
    private func loadBackgroundImages() {
        guard let resourcePath = Bundle(for: type(of: self)).resourcePath else { return }
        let fileManager = FileManager.default
        
        do {
            let files = try fileManager.contentsOfDirectory(atPath: resourcePath)
            // Filter for IS background images only, excluding TM animation files
            let heicFiles = files.filter { file in
                file.hasSuffix(".heic") && file.contains("_IS")
            }
            self.backgroundImages = heicFiles
            print("üñºÔ∏è Loaded \(heicFiles.count) IS background images")
        } catch {
            print("Error reading Resources directory: \(error.localizedDescription)")
        }
    }
    
    private func setupScene() {
        guard skView == nil else { return }  // Prevent double setup
        
        // --- Initialize Players FIRST ---
        self.queuePlayer = AVQueuePlayer()
        self.overlayPlayer = AVQueuePlayer()
        self.asPlayer = AVPlayer()  // Independent AS/SS player
        
        let skView = SKView(frame: bounds)
        skView.wantsLayer = true
        skView.layer?.backgroundColor = NSColor.clear.cgColor  // Make SKView transparent
        skView.ignoresSiblingOrder = true
        skView.allowsTransparency = true
        self.skView = skView
        addSubview(skView)
        
        let scene = SKScene(size: bounds.size)
        scene.scaleMode = .aspectFill
        scene.backgroundColor = .clear  // Scene background clear
        self.scene = scene
        
        // Layer 0: Solid Background Color
        let solidColorBGNode = SKSpriteNode(color: NSColor.black, size: scene.size)
        solidColorBGNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        solidColorBGNode.zPosition = 0
        solidColorBGNode.name = "backgroundColor"
        solidColorBGNode.alpha = 1
        scene.addChild(solidColorBGNode)
        self.backgroundColorNode = solidColorBGNode
        
        // Layer 1: Halftone Pattern
        if let bgImagePath = Bundle(for: type(of: self)).path(
            forResource: "halftone_pattern", ofType: "png"),
           let bgImage = NSImage(contentsOfFile: bgImagePath)
        {
            let bgtexture = SKTexture(image: bgImage)
            let halftone = SKSpriteNode(texture: bgtexture)
            halftone.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
            halftone.size = scene.size
            halftone.zPosition = 1
            halftone.alpha = 0  // ÂàùÂßãËÆæÁΩÆ‰∏∫ÈÄèÊòéÔºåÁõ¥Âà∞ASÂºÄÂßãÊí≠Êîæ
            halftone.name = "halftonePattern"
            halftone.blendMode = .alpha
            scene.addChild(halftone)
            self.halftoneNode = halftone
        }
        
        // Layer 2: IS Background Image
        let imageNode = SKSpriteNode()
        imageNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        imageNode.zPosition = 2
        imageNode.name = "backgroundImage"
        imageNode.blendMode = .alpha
        imageNode.alpha = 0  // ÂàùÂßãËÆæÁΩÆ‰∏∫ÈÄèÊòéÔºåÁõ¥Âà∞ASÂºÄÂßãÊí≠Êîæ
        scene.addChild(imageNode)
        self.backgroundImageNode = imageNode
        
        // Layer 3: Main Video Node - Initialize WITH player (Áî®‰∫éÊí≠ÊîæBP„ÄÅAP„ÄÅCM„ÄÅST„ÄÅRPH)
        guard let mainPlayer = self.queuePlayer else {
            print("Error: Main queuePlayer is nil during scene setup.")
            return
        }
        let videoNode = SKVideoNode(avPlayer: mainPlayer)
        videoNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        videoNode.size = scene.size
        videoNode.zPosition = 3  // Â∏∏ËßÑÂÜÖÂÆπÂú®Layer 3
        videoNode.name = "videoNode"
        scene.addChild(videoNode)
        self.videoNode = videoNode
        
        // Layer 4: Overlay Node (For VI/WE) - Initialize WITH player
        guard let ovPlayer = self.overlayPlayer else {
            print("Error: Overlay player is nil during scene setup.")
            return
        }
        let overlayNode = SKVideoNode(avPlayer: ovPlayer)
        overlayNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        overlayNode.size = scene.size  // Adjust size/position as needed for overlays
        overlayNode.zPosition = 4
        overlayNode.name = "overlayNode"
        overlayNode.isHidden = true  // Initially hidden
        scene.addChild(overlayNode)
        self.overlayNode = overlayNode
        
        // Layer 10: ÂàõÂª∫cropNode‰∏ìÈó®Áî®‰∫éAS/SSÂÜÖÂÆπÔºåÂßãÁªà‰øùÊåÅÂú®ÊúÄ‰∏äÂ±Ç‰ª•Á°Æ‰øùÈÅÆÁΩ©ÊïàÊûúÊ≠£Á°Æ
        let cropNode = SKCropNode()
        cropNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        cropNode.zPosition = 10  // AS/SSÂÜÖÂÆπÂú®ÊúÄ‰∏äÂ±ÇÔºå‰æø‰∫éÈÅÆÁΩ©Â§ÑÁêÜ
        scene.addChild(cropNode)
        self.cropNode = cropNode
        
        // AS/SS Video Node - Initialize WITH independent AS player
        guard let asPlayer = self.asPlayer else {
            print("Error: AS player is nil during scene setup.")
            return
        }
        let asVideoNode = SKVideoNode(avPlayer: asPlayer)
        asVideoNode.position = CGPoint.zero  // Position relative to cropNode
        asVideoNode.size = scene.size
        asVideoNode.name = "asVideoNode"
        asVideoNode.isHidden = true  // Initially hidden until AS content plays
        cropNode.addChild(asVideoNode)
        self.asVideoNode = asVideoNode
        
        skView.presentScene(scene)
    }
    
    private func setupPlayer() {
        guard self.queuePlayer != nil, self.overlayPlayer != nil else {
            print("Error: Players not initialized before setupPlayer call.")
            return
        }
        
        NotificationCenter.default.removeObserver(
            self, name: .AVPlayerItemDidPlayToEndTime, object: nil)
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(playerItemDidReachEnd(_:)),
            name: .AVPlayerItemDidPlayToEndTime,
            object: nil
        )
    }
    
    private func setupInitialStateAndPlay() {
        print("Setting up initial state...")
        guard let initialAS = findRandomClip(ofType: .AS) else {
            print("Error: No AS clips found to start.")
            return
        }
        print("Initial AS: \(initialAS.fileName)")
        
        // ‰∏∫ÂàùÂßãASËÆæÁΩÆÈöèÊú∫ËΩ¨Âú∫ÁºñÂè∑ÔºåÊéíÈô§006
        let availableTransitionNumbers = allClips.compactMap { clip in
            guard clip.type == .TM_Hide else { return nil }
            return clip.number
        }.filter { $0 != "006" } // ÊéíÈô§006ÁºñÂè∑
        
        if let randomNumber = availableTransitionNumbers.randomElement() {
            self.lastTransitionNumber = randomNumber
            print("üé≤ ‰∏∫ÂàùÂßãASËÆæÁΩÆÈöèÊú∫ËΩ¨Âú∫ÁºñÂè∑: \(randomNumber)")
        } else {
            print("‚ö†Ô∏è Ë≠¶ÂëäÔºöÊó†Ê≥ïÊâæÂà∞ÂèØÁî®ÁöÑËΩ¨Âú∫ÁºñÂè∑")
        }
        
        currentStateType = .playingAS
        currentClipsQueue = [initialAS]
        currentClipIndex = 0
        playNextClipInQueue()
    }
    
    // MARK: - Core Playback Logic
    
    private func playNextClipInQueue() {
        guard !isMasking else {
            print("‚è≥ ÈÅÆÁΩ©ËøáÊ∏°Ê≠£Âú®ËøõË°å‰∏≠ÔºåÂª∂ËøüÊí≠Êîæ‰∏ã‰∏Ä‰∏™‰∏ªÁâáÊÆµ„ÄÇ")
            return
        }
        guard currentClipIndex < currentClipsQueue.count else {
            print("‚úÖ ÂΩìÂâçÈòüÂàóÊí≠ÊîæÂÆåÊØï„ÄÇÂ§ÑÁêÜÂ∫èÂàóÁªìÊùü...")
            handleEndOfQueue()
            return
        }
        
        let clipToPlay = currentClipsQueue[currentClipIndex]
        print(
            "üé¨ Ê≠£Âú®Â§ÑÁêÜÁâáÊÆµ (\(currentClipIndex + 1)/\(currentClipsQueue.count)): \(clipToPlay.fileName) (\(clipToPlay.type))"
        )
        
        // È¶ñÂÖàÊõ¥Êñ∞ÂΩìÂâçÁä∂ÊÄÅÔºåÁ°Æ‰øùÁä∂ÊÄÅÊ≠£Á°Æ
        updateStateForStartingClip(clipToPlay)
        
        if clipToPlay.type == .TM_Hide || clipToPlay.type == .TM_Reveal {
            let basePattern = clipToPlay.fileName
            print("üîç TMÁâáÊÆµËØ¶ÊÉÖ: fileName=\(clipToPlay.fileName), type=\(clipToPlay.type), groupID=\(clipToPlay.groupID ?? "nil"), number=\(clipToPlay.number ?? "nil")")
            
            // ‰ΩøÁî®HEICSequencePlayerÊù•Êí≠ÊîæTMÂ∫èÂàó
            if self.heicSequencePlayer == nil {
                self.heicSequencePlayer = HEICSequencePlayer()
            }
            
            guard let player = self.heicSequencePlayer else {
                print("‚ùå ÈîôËØØÔºöÊó†Ê≥ïÂàõÂª∫HEICÂ∫èÂàóÊí≠ÊîæÂô®„ÄÇË∑≥ËøáÁâáÊÆµ [\(clipToPlay.fileName)]„ÄÇ")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // Âä†ËΩΩTMÂ∫èÂàó
            let success = player.loadSequence(basePattern: basePattern)
            if !success {
                print("‚ùå ÈîôËØØÔºöÊó†Ê≥ïÂä†ËΩΩHEICÂ∫èÂàó [\(basePattern)]„ÄÇË∑≥ËøáÁâáÊÆµ [\(clipToPlay.fileName)]„ÄÇ")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            let isRevealing = (clipToPlay.type == .TM_Reveal)
            let contentClip: SnoopyClip? =
            isRevealing ? currentClipsQueue[safe: currentClipIndex + 1] : nil
            
            startMaskTransitionWithHEIC(
                basePattern: basePattern, tmClip: clipToPlay, contentClip: contentClip, isRevealing: isRevealing)
            return
        }
        
        guard
            let url = Bundle(for: type(of: self)).url(
                forResource: clipToPlay.fileName, withExtension: nil)
        else {
            print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞ËßÜÈ¢ëÊñá‰ª∂ \(clipToPlay.fileName)")
            currentClipIndex += 1
            playNextClipInQueue()
            return
        }
        print("‚ñ∂Ô∏è Êí≠ÊîæÁâáÊÆµ: \(clipToPlay.fileName)")
        
        let newItem = AVPlayerItem(url: url)
        
        // Ê†πÊçÆÂÜÖÂÆπÁ±ªÂûãÈÄâÊã©ÈÄÇÂΩìÁöÑÊí≠ÊîæÂô®
        if clipToPlay.type == .AS || clipToPlay.type == .SS_Intro || clipToPlay.type == .SS_Loop || clipToPlay.type == .SS_Outro {
            // AS/SSÂÜÖÂÆπ‰ΩøÁî®Áã¨Á´ãÊí≠ÊîæÂô®Âú®È°∂Â±ÇÊí≠Êîæ
            self.asPlayerItem = newItem
            
            // ËÆæÁΩÆAS/SSËßÜÈ¢ëËäÇÁÇπÂèØËßÅÊÄß
            if let asVideoNode = self.asVideoNode {
                asVideoNode.isHidden = false
            }
            
            // ‰ΩøÁî®Áã¨Á´ãÁöÑASÊí≠ÊîæÂô®
            asPlayer?.replaceCurrentItem(with: newItem)
            asPlayer?.play()
            
            print("üìä AS/SSÂÜÖÂÆπ‰ΩøÁî®Áã¨Á´ãÊí≠ÊîæÂô®Âú®È°∂Â±ÇÊí≠Êîæ")
            
            // ÁõëÂê¨AS/SSÊí≠ÊîæÂÆåÊàê‰∫ã‰ª∂
            NotificationCenter.default.addObserver(
                self,
                selector: #selector(asPlaybackEnded(_:)),
                name: .AVPlayerItemDidPlayToEndTime,
                object: newItem
            )
        } else {
            // BP„ÄÅAP„ÄÅCM„ÄÅST„ÄÅRPHÁ≠âÂÜÖÂÆπ‰ΩøÁî®‰∏ªÊí≠ÊîæÂô®
            self.playerItem = newItem
            
            // Á°Æ‰øùAS/SSËßÜÈ¢ëËäÇÁÇπÈöêËóè
            if let asVideoNode = self.asVideoNode {
                asVideoNode.isHidden = true
            }
            
            queuePlayer?.removeAllItems()
            queuePlayer?.insert(newItem, after: nil)
            queuePlayer?.play()
            
            print("üìä Â∏∏ËßÑÂÜÖÂÆπ‰ΩøÁî®‰∏ªÊí≠ÊîæÂô®Âú®Layer 3Êí≠Êîæ")
        }
        
        if clipToPlay.type == .BP_Node || clipToPlay.type == .AP_Loop {
            let initialRepeatCount = max(1, clipToPlay.repeatCount)
            self.currentRepeatCount = max(0, initialRepeatCount - 1)
            print(
                "üîÅ Âæ™ÁéØÁâáÊÆµÊ£ÄÊµãÂà∞: \(clipToPlay.fileName)„ÄÇÂâ©‰ΩôÈáçÂ§çÊ¨°Êï∞: \(self.currentRepeatCount)"
            )
        } else if clipToPlay.type == .SS_Loop {
            self.currentRepeatCount = 0  // SS_Loop only plays once
            print(
                "üîÅ Âæ™ÁéØÁâáÊÆµÊ£ÄÊµãÂà∞: \(clipToPlay.fileName)„ÄÇSS_Loop ËÆæÁΩÆ‰∏∫Êí≠Êîæ‰∏ÄÊ¨°„ÄÇ"
            )
        } else {
            self.currentRepeatCount = 0
        }
        
        // VI/WE overlay logic for BP and AP loops
        if clipToPlay.type == .BP_Node || clipToPlay.type == .AP_Loop {
            let overlayChance = 0.2
            if Double.random(in: 0...1) < overlayChance {
                tryPlayVIWEOverlay()
            }
        }
    }
    
    private func updateStateForStartingClip(_ clip: SnoopyClip) {
        switch clip.type {
        case .AS:
            currentStateType = .playingAS
        case .TM_Hide:
            currentStateType = .transitioningToHalftoneHide
        case .ST_Hide:
            currentStateType = .playingSTHide
        case .RPH:
            currentStateType = .playingRPH
        case .BP_Node:
            currentStateType = .playingBP
            if let rphNode = clip.from {
                self.currentNode = rphNode
                print("üìç ÂΩìÂâçËäÇÁÇπËÆæÁΩÆ‰∏∫: \(self.currentNode ?? "nil") Êù•Ëá™ RPH")
            }
        case .AP_Intro:
            currentStateType = .playingAPIntro
        case .AP_Loop:
            currentStateType = .playingAPLoop
        case .AP_Outro:
            currentStateType = .playingAPOutro
        case .CM:
            currentStateType = .playingCM
        case .ST_Reveal:
            currentStateType = .transitioningToASReveal
        case .TM_Reveal:
            currentStateType = .playingTMReveal
        case .SS_Intro:
            currentStateType = .playingSSIntro
        default:
            print("‚ö†Ô∏è Êú™ÊòéÁ°ÆÂ§ÑÁêÜÁöÑÁâáÊÆµÁ±ªÂûã: \(clip.type)")
        }
        print("üìä ÂΩìÂâçÁä∂ÊÄÅÊõ¥Êñ∞‰∏∫: \(currentStateType)")
    }
    
    @objc private func playerItemDidReachEnd(_ notification: Notification) {
        guard !isMasking else { return }
        
        guard let finishedItem = notification.object as? AVPlayerItem else {
            print("‚ö†Ô∏è ÈÄöÁü•Êé•Êî∂Âà∞ÁöÑÂØπË±°‰∏çÊòØ AVPlayerItem„ÄÇÂøΩÁï•„ÄÇ")
            return
        }
        
        if finishedItem == self.overlayPlayerItem {
            handleOverlayItemFinish(finishedItem: finishedItem)
            return
        }
        
        // Check if this is from the AS player
        if finishedItem == self.asPlayerItem {
            print("‚úÖ AS/SSÊí≠ÊîæÂô®ÂÜÖÂÆπÊí≠ÊîæÂÆåÊàêÔºåÁî±asPlaybackEndedÂ§ÑÁêÜ")
            // AS/SS playback completion is handled by asPlaybackEnded
            return
        }
        
        guard finishedItem == self.playerItem else {
            print("‚ö†Ô∏è ÈÄöÁü•Êé•Êî∂Âà∞ÊÑèÂ§ñÁöÑÊí≠ÊîæÂô®È°πÁõÆ„ÄÇÂøΩÁï•„ÄÇ")
            return
        }
        print("‚úÖ ‰∏ªÊí≠ÊîæÂô®ÂÜÖÂÆπÊí≠ÊîæÂÆåÊàê„ÄÇ")
        
        if currentRepeatCount > 0 {
            print("üîÅ Âæ™ÁéØÁâáÊÆµ„ÄÇÂâ©‰ΩôÈáçÂ§çÊ¨°Êï∞: \(currentRepeatCount - 1)")
            if let url = (finishedItem.asset as? AVURLAsset)?.url {
                let newItem = AVPlayerItem(url: url)
                self.playerItem = newItem
                
                queuePlayer?.removeAllItems()
                queuePlayer?.insert(newItem, after: nil)
                currentRepeatCount -= 1
                queuePlayer?.play()
                return
            }
        }
        
        guard currentClipIndex < currentClipsQueue.count else {
            print("‚ùå ÈîôËØØÔºöplayerItemDidReachEnd Ë∞ÉÁî®Êó∂Á¥¢ÂºïË∂ÖÂá∫ËåÉÂõ¥„ÄÇ")
            return
        }
        let finishedClip = currentClipsQueue[currentClipIndex]
        
        guard finishedClip.type != .TM_Hide && finishedClip.type != .TM_Reveal else {
            print("‚ùå ÈîôËØØÔºö‰∏ªÊí≠ÊîæÂô®ÊÑèÂ§ñÂÆåÊàê TM ÁâáÊÆµ„ÄÇ")
            currentClipIndex += 1
            playNextClipInQueue()
            return
        }
        print("‚úÖ ÂÆåÊàê‰∏ªÁâáÊÆµ: \(finishedClip.fileName)")
        
        
        // BP_To_RPHÊí≠ÊîæÂÆåÊØïÔºåÈ¢ÑÂä†ËΩΩTM_RevealÂíåAS‰ª•‰æøÂú®ST_RevealÊí≠ÊîæÂÆåÊàêÂêéÁ´ãÂç≥‰ΩøÁî®
        if finishedClip.type == .BP_To && finishedClip.to?.starts(with: "RPH") ?? false {
            print("üé¨ BP_To_RPH ÂÆåÊàê„ÄÇÈ¢ÑÂä†ËΩΩTM_RevealÂíåAS„ÄÇ")
            
            // Ê£ÄÊü•‰∏ã‰∏Ä‰∏™ÊòØÂê¶ÊòØST_Reveal
            if currentClipIndex + 1 < currentClipsQueue.count
                && currentClipsQueue[currentClipIndex + 1].type == .ST_Reveal
            {
                // TM_Reveal preloading removed - now handled by HEIC sequence player
                print("üîÑ Next clip is ST_Reveal - TM transitions now handled by HEIC sequence player")
            }
        }
        
        // ST_RevealÊí≠ÊîæÂÆåÊØïÔºåÂºÄÂßãTM_RevealÂíåASÁöÑÊí≠ÊîæÊµÅÁ®ã
        if finishedClip.type == .ST_Reveal {
            print("üé¨ ST_Reveal ÂÆåÊàê„ÄÇÁªßÁª≠Â∫èÂàó„ÄÇ")
            
            // Â¶ÇÊûú‰∏ã‰∏Ä‰∏™ÊòØTM_RevealÔºå‰ΩøÁî®TM_RevealËøáÊ∏°
            if currentClipIndex + 1 < currentClipsQueue.count
                && currentClipsQueue[currentClipIndex + 1].type == .TM_Reveal
            {
                // Á¨¨‰∏ÄÊ¨°Ë∞ÉÁî®playerItemDidReachEndÊó∂ÔºåÊàë‰ª¨Â∑≤ÁªèÈ¢ÑÂä†ËΩΩTM_RevealÂíåAS
                // Â¢ûÂä†Á¥¢ÂºïÂπ∂Êí≠Êîæ‰∏ã‰∏Ä‰∏™ÁâáÊÆµÔºåËøôÂ∞ÜËß¶ÂèëTM_RevealÁöÑÂºÄÂßã
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
        }
        
        // Ê†πÊçÆÈúÄÊ±ÇÊñáÊ°£ÔºöÂè™ÊúâÂàùÊ¨°ASÊí≠ÊîæÂÆåÊàêÂêéÊâçÂä†ËΩΩËÉåÊôØ
        // ÂêéÁª≠‰ªéBPË∑≥ËΩ¨Âà∞ASÁöÑ‰∏çÈúÄË¶ÅÈáçÊñ∞Âä†ËΩΩËÉåÊôØÔºåÂõ†‰∏∫ËÉåÊôØÂú®È¶ñÊ¨°ASÂêéÂ∑≤ÁªèÂä†ËΩΩ‰∫Ü
        if finishedClip.type == .AS && isFirstASPlayback {
            print("üé¨ ÂàùÊ¨°ASÊí≠ÊîæÂÆåÊàêÔºåÁé∞Âú®Âä†ËΩΩËÉåÊôØ")
            updateBackgrounds()
            isFirstASPlayback = false  // Ê†áËÆ∞ÂàùÊ¨°ASÊí≠ÊîæÂ∑≤ÂÆåÊàê
        } else if finishedClip.type == .SS_Outro {
            updateBackgrounds()
        }
        
        // ÁâπÊÆäÂ§ÑÁêÜÔºöÂ¶ÇÊûúASÊòØÈÄöËøáTM_RevealËøáÊ∏°ÊòæÁ§∫ÁöÑÔºå‰∏çË∞ÉÁî®generateNextSequence
        // Âõ†‰∏∫ÂêéÁª≠Â∫èÂàó‰ºöÁî±HEICÂÆåÊàêÂõûË∞ÉÂ§ÑÁêÜ
        if finishedClip.type == .AS && currentStateType == .playingTMReveal {
            print("üîç ASÈÄöËøáTM_RevealËøáÊ∏°ÊòæÁ§∫ÔºåË∑≥ËøágenerateNextSequenceÔºåÁ≠âÂæÖHEICÂÆåÊàêÂõûË∞ÉÂ§ÑÁêÜ")
            currentClipIndex += 1
            // ‰∏çË∞ÉÁî®playNextClipInQueueÔºåÂõ†‰∏∫TM_Hide‰ºöÁî±HEICÁ≥ªÁªüÂ§ÑÁêÜ
            return
        }
        
        generateNextSequence(basedOn: finishedClip)
        
        currentClipIndex += 1
        playNextClipInQueue()
    }
    
    @objc private func asPlaybackEnded(_ notification: Notification) {
        print("‚úÖ ASËßÜÈ¢ëÊí≠ÊîæÂÆåÊØï")
        
        // ÁßªÈô§Ëøô‰∏™ÁâπÂÆöÁöÑÈÄöÁü•ËßÇÂØüËÄÖ
        if let item = notification.object as? AVPlayerItem {
            NotificationCenter.default.removeObserver(
                self, name: .AVPlayerItemDidPlayToEndTime, object: item)
        }
        
        // Ê£ÄÊü•ÂΩìÂâçÁä∂ÊÄÅÊù•ÂÜ≥ÂÆöÂ¶Ç‰ΩïÂ§ÑÁêÜASÂÆåÊàê
        if currentStateType == .playingTMReveal {
            // ASÊòØÈÄöËøáTM_RevealËøáÊ∏°ÊòæÁ§∫ÁöÑÔºåÂú®ËøôÈáåÂ§ÑÁêÜTM_Hide
            print("üîç ASÊòØÈÄöËøáTM_RevealÊòæÁ§∫ÁöÑÔºåÂú®asPlaybackEnded‰∏≠ÂêØÂä®TM_Hide")
            handleASCompletionWithTMHide()
        } else if currentStateType == .playingAS && isFirstASPlayback {
            // ÂàùÂßãASÊí≠ÊîæÂÆåÊàêÔºåÈúÄË¶ÅÂä†ËΩΩËÉåÊôØÂπ∂Êí≠ÊîæTM_Hide
            print("üîç ÂàùÂßãASÊí≠ÊîæÂÆåÊàêÔºåÂä†ËΩΩËÉåÊôØÂπ∂ÂêØÂä®TM_Hide")
            
            // Ê†πÊçÆÈúÄÊ±ÇÊñáÊ°£ÔºöÂàùÊ¨°ASÊí≠ÊîæÂÆåÊàêÂêéÊâçÂä†ËΩΩËÉåÊôØ
            updateBackgrounds()
            isFirstASPlayback = false  // Ê†áËÆ∞ÂàùÊ¨°ASÊí≠ÊîæÂ∑≤ÂÆåÊàê
            
            // ÁÑ∂ÂêéÂêØÂä®TM_HideËøáÊ∏°
            handleASCompletionWithTMHide()
        } else {
            print("üîç AS‰∏çÊòØÈÄöËøáTM_RevealÊòæÁ§∫ÁöÑÔºå‰∏î‰∏çÊòØÂàùÂßãÊí≠ÊîæÔºåTM_HideÂ∑≤Áî±playerItemDidReachEndÂ§ÑÁêÜÔºåË∑≥ËøáasPlaybackEndedÁöÑTM_HideÂ§ÑÁêÜ")
            return
        }
    }
    
    private func handleASCompletionWithTMHide() {
        // ËÆæÁΩÆÁä∂ÊÄÅ‰∏∫ÈöêËóèËøáÊ∏°
        currentStateType = .transitioningToHalftoneHide
        
        // Ê£ÄÊü•ÊòØÂê¶ÊúâÊúâÊïàÁöÑlastTransitionNumberÁî®‰∫éÂåπÈÖçTM_Hide
        if let transitionNumber = self.lastTransitionNumber {
            print("üîç ASÊí≠ÊîæÂÆåÊàêÔºå‰ΩøÁî®‰øùÂ≠òÁöÑËΩ¨Âú∫ÁºñÂè∑ \(transitionNumber) Êù•ÂêØÂä®ÂåπÈÖçÁöÑTM_Hide")
            
            // ÊâæÂà∞ÂåπÈÖçÁöÑTM_HideÂπ∂Áõ¥Êé•ÂêØÂä®HEICÊí≠ÊîæÂô®
            if let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber) {
                print("‚úÖ ÊâæÂà∞ÂåπÈÖçÁöÑTM_Hide: \(tmHide.fileName)")
                startTMHideTransition(tmHide: tmHide)
            } else {
                print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞ÂåπÈÖçËΩ¨Âú∫ÁºñÂè∑ \(transitionNumber) ÁöÑTM_Hide")
                // ÂõûÈÄÄÔºö‰ΩøÁî®ÈöèÊú∫TM_Hide
                if let randomTMHide = findRandomClip(ofType: .TM_Hide) {
                    print("üîÑ ÂõûÈÄÄÔºö‰ΩøÁî®ÈöèÊú∫TM_Hide: \(randomTMHide.fileName)")
                    startTMHideTransition(tmHide: randomTMHide)
                }
            }
        } else {
            // Ê≤°ÊúâÂ≠òÂÇ®ÁöÑËΩ¨Âú∫ÁºñÂè∑Ôºå‰ΩøÁî®ÈöèÊú∫TM_Hide
            print("üîç Ê≤°ÊúâÂ≠òÂÇ®ÁöÑËΩ¨Âú∫ÁºñÂè∑Ôºå‰ΩøÁî®ÈöèÊú∫TM_Hide")
            if let randomTMHide = findRandomClip(ofType: .TM_Hide) {
                print("‚úÖ ÊâæÂà∞ÈöèÊú∫TM_Hide: \(randomTMHide.fileName)")
                startTMHideTransition(tmHide: randomTMHide)
            } else {
                print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞‰ªª‰ΩïTM_HideÁâáÊÆµ")
            }
        }
    }
    
    private func startTMHideTransition(tmHide: SnoopyClip) {
        // Áõ¥Êé•Êí≠ÊîæTM_HideÔºåËÄå‰∏çÊòØÈÄöËøáÈòüÂàóÁ≥ªÁªü
        if self.heicSequencePlayer == nil {
            self.heicSequencePlayer = HEICSequencePlayer()
        }
        
        guard let player = self.heicSequencePlayer else {
            print("‚ùå ÈîôËØØÔºöÊó†Ê≥ïÂàõÂª∫HEICÂ∫èÂàóÊí≠ÊîæÂô®")
            return
        }
        
        let success = player.loadSequence(basePattern: tmHide.fileName)
        if success {
            print("üé≠ Áõ¥Êé•ÂêØÂä®TM_Hide HEICÂ∫èÂàó: \(tmHide.fileName)")
            isMasking = true
            
            // ËÆæÁΩÆÈÅÆÁΩ©Âπ∂Êí≠Êîæ
            if let scene = self.scene,
               let maskNode = self.tmMaskSpriteNode,
               let asVideoNode = self.asVideoNode,
               let cropNode = self.cropNode {
                
                // Á°Æ‰øùASËßÜÈ¢ëËäÇÁÇπÂú®cropNode‰∏≠
                if asVideoNode.parent != cropNode {
                    asVideoNode.removeFromParent()
                    asVideoNode.position = .zero
                    cropNode.addChild(asVideoNode)
                }
                
                player.startAnimation(
                    scene: scene,
                    maskNode: maskNode,
                    targetVideoNode: asVideoNode,
                    cropNode: cropNode,
                    isRevealing: false,  // TM_Hide
                    completion: { [weak self] in
                        self?.heicSequenceMaskCompleted(
                            basePattern: tmHide.fileName,
                            isRevealing: false,
                            tmClip: tmHide
                        )
                    }
                )
            } else {
                print("‚ùå ÈîôËØØÔºöÁº∫Â∞ëÂøÖË¶ÅÁöÑËäÇÁÇπÊù•ÂêØÂä®TM_HideËøáÊ∏°")
            }
        } else {
            print("‚ùå ÈîôËØØÔºöÊó†Ê≥ïÂä†ËΩΩTM_Hide HEICÂ∫èÂàó: \(tmHide.fileName)")
        }
    }
    
    // MARK: - Overlay Management
    
    @objc private func ssOutroPlaybackEnded(_ notification: Notification) {
        print("‚úÖ SS_OutroËßÜÈ¢ëÊí≠ÊîæÂÆåÊØïÔºåÂª∂Ëøü2ÁßíÂêéÂ∞ÜÂºÄÂßãÊí≠ÊîæTM_Hide")
        
        // ÁßªÈô§Ëøô‰∏™ÁâπÂÆöÁöÑÈÄöÁü•ËßÇÂØüËÄÖ
        if let item = notification.object as? AVPlayerItem {
            NotificationCenter.default.removeObserver(
                self, name: .AVPlayerItemDidPlayToEndTime, object: item)
        }
        
        // ËÆæÁΩÆÁä∂ÊÄÅ‰∏∫ÈöêËóèËøáÊ∏°
        currentStateType = .transitioningToHalftoneHide
        
        // Ê∏ÖÈô§ÂΩìÂâçÈòüÂàóÔºåÈò≤Ê≠¢TM_HideÊí≠ÊîæÊó∂Ëß¶ÂèëplayerItemDidReachEnd
        // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÊâÄÊúâËΩ¨Âú∫Áî±maskPlayerItemDidReachEndÊéßÂà∂
        if currentClipsQueue.count > 0 && currentClipIndex < currentClipsQueue.count {
            print("üîÑ SSÁªìÊùüÔºåÊ∏ÖÈô§ÂΩìÂâçÊí≠ÊîæÈòüÂàóÔºåÁ≠âÂæÖTM_HideÂÆåÊàê")
        }
        
        // Â¶ÇÊûúÊúâÂ≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµÔºåÂ∫îËØ•‰ΩøÁî®Ëøô‰∫õÁâáÊÆµÔºåËÄå‰∏çÊòØÈáçÊñ∞ÁîüÊàêÂ∫èÂàó
        if !nextAfterAS.isEmpty {
            print("üé¨ SSÂÆåÊàêÔºå‰ΩøÁî®Â≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµÔºö\(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
            
            // Á°ÆËÆ§nextAfterASÊòØÂê¶ÂåÖÂê´Êàë‰ª¨ÈúÄË¶ÅÁöÑÁâáÊÆµ
            let hasAllRequiredTypes =
            nextAfterAS.contains(where: { $0.type == .TM_Hide })
            && nextAfterAS.contains(where: { $0.type == .ST_Hide })
            && nextAfterAS.contains(where: { $0.type == .RPH })
            && nextAfterAS.contains(where: { $0.type == .BP_Node })
            
            if !hasAllRequiredTypes {
                print("‚ö†Ô∏è nextAfterAS‰∏çÂÆåÊï¥ÔºåÁº∫Â∞ëÂøÖË¶ÅÁ±ªÂûã„ÄÇÈáçÊñ∞ÁîüÊàêÈòüÂàó„ÄÇ")
                // Â¶ÇÊûúÊ≤°ÊúâÂøÖË¶ÅÁöÑÁ±ªÂûãÔºåÈáçÊñ∞ÁîüÊàê
                if let finishedClip = findClipForPlayerItem(self.playerItem!) {
                    print("üìä SSÊí≠ÊîæÂÆåÊàêÔºåÈáçÊñ∞ÁîüÊàê‰∏ã‰∏Ä‰∏™Â∫èÂàó")
                    generateNextSequence(basedOn: finishedClip)
                }
            } else {
                // Â∞ÜÂêéÁª≠ÁâáÊÆµËÆæÁΩÆ‰∏∫ÂΩìÂâçÈòüÂàó
                currentClipsQueue = nextAfterAS
                currentClipIndex = 0
                print("‚úÖ Â∑≤ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™ÈòüÂàó‰∏∫Â≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµ")
            }
            
            // Ê∏ÖÁ©∫Â≠òÂÇ®ÔºåÈò≤Ê≠¢ÈáçÂ§ç‰ΩøÁî®
            nextAfterAS = []
        } else if let finishedClip = findClipForPlayerItem(self.playerItem!) {
            // Â¶ÇÊûúÊ≤°ÊúâÂ≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµÔºåÂàôÈÄöËøáÂ∏∏ËßÑÊñπÂºèÁîüÊàê‰∏ã‰∏Ä‰∏™Â∫èÂàó
            print("üìä SSÊí≠ÊîæÂÆåÊàêÔºåÈ¢ÑÂÖàÁîüÊàê‰∏ã‰∏Ä‰∏™Â∫èÂàó")
            generateNextSequence(basedOn: finishedClip)
            
            // ÊâìÂç∞ÁîüÊàêÁöÑÈòüÂàó‰ø°ÊÅØ‰ª•‰æøË∞ÉËØï
            print("üîç Debug - ÁîüÊàêÁöÑÊñ∞ÈòüÂàóÂåÖÂê´ \(currentClipsQueue.count) ‰∏™ÁâáÊÆµ:")
            for (index, clip) in currentClipsQueue.enumerated() {
                print("  [\(index)]: \(clip.fileName) (\(clip.type))")
            }
            
            // ÁâπÂà´Ê£ÄÊü•ÔºöÁ°Æ‰øùÈòüÂàó‰ª•TM_HideÂºÄÂ§¥Ôºå‰∏îÂåÖÂê´ST_Hide„ÄÅRPHÂíåBP_Node
            let isValidQueue =
            currentClipsQueue.count >= 4 && currentClipsQueue[0].type == .TM_Hide
            && currentClipsQueue[1].type == .ST_Hide && currentClipsQueue[2].type == .RPH
            && currentClipsQueue[3].type == .BP_Node
            
            if !isValidQueue {
                print("‚ö†Ô∏è ÁîüÊàêÁöÑÈòüÂàó‰∏çÂåÖÂê´Ê≠£Á°ÆÁöÑÂ∫èÂàó„ÄÇÂ∞ùËØï‰øÆÂ§çÈòüÂàó„ÄÇ")
                
                // Â∞ùËØïÊâãÂä®ÊûÑÂª∫Ê≠£Á°ÆÁöÑÈòüÂàó
                if let tmHide = findRandomClip(
                    ofType: .TM_Hide, matchingNumber: lastTransitionNumber)
                {
                    print("‚úÖ ÊâæÂà∞TM_Hide: \(tmHide.fileName)")
                    
                    if let stHide = findMatchingST(for: tmHide, type: .ST_Hide) {
                        print("‚úÖ ÊâæÂà∞ST_Hide: \(stHide.fileName)")
                        
                        if let randomRPH = findRandomClip(ofType: .RPH) {
                            print("‚úÖ ÊâæÂà∞RPH: \(randomRPH.fileName)")
                            
                            if let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to)
                            {
                                print("‚úÖ ÊâæÂà∞BP_Node: \(targetBPNode.fileName)")
                                
                                currentClipsQueue = [tmHide, stHide, randomRPH, targetBPNode]
                                currentClipIndex = 0
                                print("‚úÖ ‰øÆÂ§çÈòüÂàóÊàêÂäü")
                            }
                        }
                    }
                }
            }
        }
        
        
        // ÂºÄÂßãÊí≠ÊîæTM_HideËßÜÈ¢ëÔºàÁé∞Âú®‰ΩøÁî®HEICÂ∫èÂàóÊí≠ÊîæÂô®Ôºâ
        print("üé¨ SSÊí≠ÊîæÁªìÊùüÔºåTM_HideÂ∞ÜÈÄöËøáHEICÂ∫èÂàóÊí≠ÊîæÂô®Â§ÑÁêÜ")
    }
    
    private func generateNextSequence(basedOn finishedClip: SnoopyClip) {
        print(
            "üìä Âü∫‰∫éÂÆåÊàêÁöÑÁâáÊÆµÁîüÊàê‰∏ã‰∏Ä‰∏™Â∫èÂàó: \(finishedClip.fileName) (Á±ªÂûã: \(finishedClip.type), Áä∂ÊÄÅ: \(currentStateType))"
        )
        var nextQueue: [SnoopyClip] = []
        
        switch finishedClip.type {
        case .AS:
            print("üé¨ AS ÂÆåÊàê„ÄÇÈòüÂàó Halftone ËøáÊ∏°„ÄÇ")
            
            let requiredNumber = self.lastTransitionNumber
            print("üîç Debug: lastTransitionNumber = \(requiredNumber ?? "nil")")
            
            guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: requiredNumber)
            else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫ \(requiredNumber ?? "any") ÁöÑ TM_Hide")
                // Don't reset lastTransitionNumber here, keep it for potential retry
                break
            }
            
            // Only reset lastTransitionNumber after successful finding of TM_Hide
            self.lastTransitionNumber = nil
            print("‚úÖ Guard OK: Found TM_Hide: \(tmHide.fileName)")
            
            guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÂåπÈÖç TM \(tmHide.number ?? "") ÁöÑ ST_Hide")
                break
            }
            print("‚úÖ Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÈöèÊú∫ RPH")
                break
            }
            print("‚úÖ Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "‚ùå Guard Failed: Êâæ‰∏çÂà∞ RPH \(randomRPH.fileName) ÊåáÂêëÁöÑ BP ËäÇÁÇπ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("‚úÖ Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂÇ®‰∫ÜnextAfterASÔºåÂ¶ÇÊûúÂ≠òÂÇ®‰∫ÜÂ∞±‰ΩøÁî®ÂÆÉ
            if !nextAfterAS.isEmpty {
                print(
                    "üé¨ ASÂÆåÊàêÔºå‰ΩøÁî®Â∑≤Â≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµ: \(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
                nextQueue = nextAfterAS
                nextAfterAS = []  // Ê∏ÖÁ©∫Â≠òÂÇ®ÔºåÈò≤Ê≠¢ÈáçÂ§ç‰ΩøÁî®
            } else {
                // Â¶ÇÊûúÊ≤°ÊúâÂ≠òÂÇ®Ôºå‰ΩøÁî®ÂàöÁîüÊàêÁöÑÂ∫èÂàó
                nextQueue = [tmHide, stHide, randomRPH, targetBPNode]
                print("üé¨ ASÂÆåÊàêÔºå‰ΩøÁî®Êñ∞ÁîüÊàêÁöÑÂêéÁª≠ÁâáÊÆµ")
            }
            
        case .BP_Node:
            print("üé¨ BP ËäÇÁÇπÂÆåÊàêÂæ™ÁéØ„ÄÇÂΩìÂâçËäÇÁÇπ: \(currentNode ?? "nil"), Âë®ÊúüËÆ°Êï∞: \(bpCycleCount)")
            currentStateType = .decidingNextHalftoneAction
            
            if bpCycleCount == 1 {
                print("üîÑ Â∑≤ÂÆåÊàê \(bpCycleCount) ‰∏™ BP Âë®ÊúüÔºåÈöèÊú∫ÈÄâÊã© AS, SS Êàñ Halftone Â∫èÂàó„ÄÇ")
                bpCycleCount = 0
                
                let choice = Double.random(in: 0..<1)
                let asProbability = 0.9
                let ssProbability = 0.0
                
                if choice < asProbability {
                    print("  ÈÄâÊã©ÁîüÊàê AS Â∫èÂàó„ÄÇ")
                    // ÁâπÊÆäÂ§ÑÁêÜÔºöBP001ÊúâÊ¶ÇÁéáËøõÂÖ•ASÂ∫èÂàóÔºà‰ΩøÁî®Âõ∫ÂÆö006ÁºñÂè∑Ôºâ
                    if currentNode == "BP001" {
                        print("üéØ BP001ÈÄâÊã©ËøõÂÖ•ASÂ∫èÂàóÔºà‰ΩøÁî®Âõ∫ÂÆö006ÁºñÂè∑Ôºâ")
                        nextQueue = generateBP001ASSequence()
                    } else {
                        nextQueue = generateASSequence(fromNode: currentNode)
                    }
                } else if choice < asProbability + ssProbability {
                    print("  ÈÄâÊã©ÁîüÊàê SS Â∫èÂàó„ÄÇ")
                    nextQueue = generateSSSequenceNew(fromNode: currentNode)
                } else {
                    print("  ÈÄâÊã©ÁîüÊàê Halftone ËΩ¨Êç¢Â∫èÂàó (ÁªßÁª≠)„ÄÇ")
                    guard let nodeName = currentNode else {
                        print("‚ùå ÈîôËØØÔºöBP_Node ÂÆåÊàêÊó∂ currentNode ‰∏∫ nil„ÄÇÂõûÈÄÄ„ÄÇ")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    let nextSequenceFileNames = SnoopyClip.generatePlaySequence(
                        currentNode: nodeName, clips: allClips)
                    nextQueue = nextSequenceFileNames.compactMap { findClip(byFileName: $0) }
                    if nextQueue.isEmpty {
                        print("‚ö†Ô∏è Êú™ÊâæÂà∞ÂêàÈÄÇÁöÑ AP/CM/BP_To ËΩ¨Êç¢„ÄÇÂõûÈÄÄ„ÄÇ")
                        nextQueue = generateFallbackSequence()
                    }
                }
            } else {
                print("  Âë®ÊúüÊï∞Êú™Ëææ 5 ÁöÑÂÄçÊï∞ (ÂΩìÂâç: \(bpCycleCount))ÔºåÈÄâÊã©‰∏ã‰∏Ä‰∏™ Halftone Âä®‰Ωú„ÄÇ")
                
                
                guard let nodeName = currentNode else {
                    print("‚ùå ÈîôËØØÔºöBP_Node ÂÆåÊàêÊó∂ currentNode ‰∏∫ nil„ÄÇÂõûÈÄÄ„ÄÇ")
                    nextQueue = generateFallbackSequence()
                    break
                }
                let nextSequenceFileNames = SnoopyClip.generatePlaySequence(
                    currentNode: nodeName, clips: allClips)
                nextQueue = nextSequenceFileNames.compactMap { findClip(byFileName: $0) }
                if nextQueue.isEmpty {
                    print("‚ö†Ô∏è Êú™ÊâæÂà∞ÂêàÈÄÇÁöÑ AP/CM/BP_To ËΩ¨Êç¢„ÄÇÂõûÈÄÄ„ÄÇ")
                    nextQueue = generateFallbackSequence()
                }
            }
            
        case .AP_Outro, .CM, .BP_To, .RPH:
            print("üé¨ \(finishedClip.type) ÂÆåÊàê„ÄÇËΩ¨Âà∞ËäÇÁÇπ: \(finishedClip.to ?? "nil")")
            
            if finishedClip.type == .RPH {
                // RPHÂÆåÊàêÔºåÊï¥‰∏™AS/SS ‚Üí TM_Hide ‚Üí ST_Hide ‚Üí RPHÂ∫èÂàóÁªìÊùüÔºåÈáçÁΩÆËΩ¨Âú∫ÁºñÂè∑
                print("üîÑ RPHÂÆåÊàêÔºåÈáçÁΩÆlastTransitionNumber")
                self.lastTransitionNumber = nil
                
                // Ê£ÄÊü•RPHÊòØÂê¶Âú®È¢ÑÊûÑÂª∫ÁöÑÂ∫èÂàó‰∏≠Ôºà‰∏ã‰∏Ä‰∏™Â∫îËØ•ÊòØBP_NodeÔºâ
                if let nextClipInQueue = currentClipsQueue[safe: currentClipIndex + 1],
                   nextClipInQueue.type == .BP_Node
                {
                    print("üé¨ RPH (part of sequence) ÂÆåÊàê„ÄÇÁªßÁª≠Â∫èÂàóÂà∞ BP_Node: \(nextClipInQueue.fileName)")
                    // Êõ¥Êñ∞ÂΩìÂâçËäÇÁÇπ
                    self.currentNode = finishedClip.to
                    return
                } else {
                    // RPH‰∏çÂú®È¢ÑÊûÑÂª∫ÁöÑÂ∫èÂàó‰∏≠ÔºåÈúÄË¶ÅÁîüÊàêÊñ∞ÁöÑBP_NodeÈòüÂàó
                    self.currentNode = finishedClip.to
                    guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                    else {
                        print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞ÁõÆÊ†á BP ËäÇÁÇπ \(self.currentNode ?? "nil")„ÄÇÂõûÈÄÄ„ÄÇ")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    print("‚úÖ RPH ÂÆåÊàêÔºåÈòüÂàóÁõÆÊ†á BP ËäÇÁÇπ: \(targetBPNode.fileName)")
                    nextQueue = [targetBPNode]
                    bpCycleCount += 1
                    print("üîÑ Â¢ûÂä† BP Âë®ÊúüËÆ°Êï∞Ëá≥: \(bpCycleCount)")
                }
            } else if finishedClip.type == .BP_To {
                if finishedClip.to?.starts(with: "RPH") ?? false {
                    if let nextClipInQueue = currentClipsQueue[safe: currentClipIndex + 1],
                       nextClipInQueue.type == .ST_Reveal
                    {
                        print("üé¨ BP_To_RPH (part of AS sequence) ÂÆåÊàê„ÄÇÁªßÁª≠Â∫èÂàó (ST_Reveal)„ÄÇ")
                        
                        // Ê∏ÖÈô§ÊâÄÊúâÂ≠òÂÇ®ÁöÑË∑≥ËΩ¨ÂêéÂ∫èÂàóÔºåÈò≤Ê≠¢Âæ™ÁéØ
                        if !nextAfterAS.isEmpty {
                            print("‚ö†Ô∏è BP_To_RPHÂ∫èÂàóÂºÄÂßãÔºåÊ∏ÖÈô§Â∑≤Â≠òÂÇ®ÁöÑnextAfterASÈò≤Ê≠¢Âæ™ÁéØ")
                            nextAfterAS = []
                        }
                        return
                    } else {
                        guard let randomRPH = findRandomClip(ofType: .RPH) else {
                            print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞‰ªª‰Ωï RPH ÁâáÊÆµÊù•Â§ÑÁêÜ BP_To_RPH ÂÆåÊàê„ÄÇÂõûÈÄÄ„ÄÇ")
                            nextQueue = generateFallbackSequence()
                            break
                        }
                        print("‚úÖ BP_To_RPH ÂÆåÊàêÔºåÈòüÂàóÈöèÊú∫ RPH: \(randomRPH.fileName)")
                        nextQueue = [randomRPH]
                    }
                } else {
                    self.currentNode = finishedClip.to
                    guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                    else {
                        print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞ÁõÆÊ†á BP ËäÇÁÇπ \(self.currentNode ?? "nil")„ÄÇÂõûÈÄÄ„ÄÇ")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    print("‚úÖ BP_To_BP ÂÆåÊàêÔºåÈòüÂàóÁõÆÊ†á BP ËäÇÁÇπ: \(targetBPNode.fileName)")
                    nextQueue = [targetBPNode]
                    bpCycleCount += 1
                    print("üîÑ Â¢ûÂä† BP Âë®ÊúüËÆ°Êï∞Ëá≥: \(bpCycleCount)")
                }
            } else {
                // Â§ÑÁêÜÂÖ∂‰ªñÁ±ªÂûã(.AP_Outro, .CM)
                self.currentNode = finishedClip.to
                guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                else {
                    print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞ÁõÆÊ†á BP ËäÇÁÇπ \(self.currentNode ?? "nil")„ÄÇÂõûÈÄÄ„ÄÇ")
                    nextQueue = generateFallbackSequence()
                    break
                }
                print("‚úÖ \(finishedClip.type) ÂÆåÊàêÔºåÈòüÂàóÁõÆÊ†á BP ËäÇÁÇπ: \(targetBPNode.fileName)")
                nextQueue = [targetBPNode]
                bpCycleCount += 1
                print("üîÑ Â¢ûÂä† BP Âë®ÊúüËÆ°Êï∞Ëá≥: \(bpCycleCount)")
            }
            
        case .ST_Hide, .ST_Reveal:
            print("üé¨ \(finishedClip.type) ÂÆåÊàê„ÄÇÁªßÁª≠Â∫èÂàó„ÄÇ")
            return
            
        case .TM_Hide:
            print("üé¨ TM_Hide ÂÆåÊàê„ÄÇÁîüÊàê ST_Hide ‚Üí RPH ‚Üí BP_Node Â∫èÂàó„ÄÇ")
            
            guard let transitionNumber = finishedClip.number else {
                print("‚ùå Guard Failed: TM_Hide Ê≤°ÊúâÊúâÊïàÁöÑËΩ¨Âú∫ÁºñÂè∑")
                break
            }
            
            guard let stHide = findMatchingST(forNumber: transitionNumber, type: .ST_Hide) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÂåπÈÖç TM \(transitionNumber) ÁöÑ ST_Hide")
                break
            }
            print("‚úÖ Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÈöèÊú∫ RPH")
                break
            }
            print("‚úÖ Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "‚ùå Guard Failed: Êâæ‰∏çÂà∞ RPH \(randomRPH.fileName) ÊåáÂêëÁöÑ BP ËäÇÁÇπ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("‚úÖ Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            nextQueue = [stHide, randomRPH, targetBPNode]
            print("üé¨ TM_HideÂÆåÊàêÔºå‰ΩøÁî®Êñ∞ÁîüÊàêÁöÑÂ∫èÂàó: \(nextQueue.map { $0.fileName }.joined(separator: ", "))")
            
        case .TM_Reveal:
            print("‚ùå ÈîôËØØÔºöTM ÁâáÊÆµÂú®‰∏ªÊí≠ÊîæÂô®Â∫èÂàóÁîüÊàê‰∏≠ÂÆåÊàê„ÄÇ")
            break
            
        case .SS_Outro:
            print("üé¨ SS ÂÆåÊàê„ÄÇÈòüÂàó Halftone ËøáÊ∏°„ÄÇ")
            
            let requiredNumber = self.lastTransitionNumber
            print("üîç Debug: lastTransitionNumber = \(requiredNumber ?? "nil")")
            
            guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: requiredNumber)
            else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫ \(requiredNumber ?? "any") ÁöÑ TM_Hide")
                // Don't reset lastTransitionNumber here, keep it for potential retry
                break
            }
            
            // Only reset lastTransitionNumber after successful finding of TM_Hide
            self.lastTransitionNumber = nil
            print("‚úÖ Guard OK: Found TM_Hide: \(tmHide.fileName)")
            
            guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÂåπÈÖç TM \(tmHide.number ?? "") ÁöÑ ST_Hide")
                break
            }
            print("‚úÖ Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÈöèÊú∫ RPH")
                break
            }
            print("‚úÖ Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "‚ùå Guard Failed: Êâæ‰∏çÂà∞ RPH \(randomRPH.fileName) ÊåáÂêëÁöÑ BP ËäÇÁÇπ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("‚úÖ Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂÇ®‰∫ÜnextAfterASÔºåÂ¶ÇÊûúÂ≠òÂÇ®‰∫ÜÂ∞±‰ΩøÁî®ÂÆÉ
            if !nextAfterAS.isEmpty {
                print(
                    "üé¨ SSÂÆåÊàêÔºå‰ΩøÁî®Â∑≤Â≠òÂÇ®ÁöÑÂêéÁª≠ÁâáÊÆµ: \(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
                nextQueue = nextAfterAS
                nextAfterAS = []  // Ê∏ÖÁ©∫Â≠òÂÇ®ÔºåÈò≤Ê≠¢ÈáçÂ§ç‰ΩøÁî®
            } else {
                // Â¶ÇÊûúÊ≤°ÊúâÂ≠òÂÇ®Ôºå‰ΩøÁî®ÂàöÁîüÊàêÁöÑÂ∫èÂàó
                nextQueue = [tmHide, stHide, randomRPH, targetBPNode]
                print("üé¨ SSÂÆåÊàêÔºå‰ΩøÁî®Êñ∞ÁîüÊàêÁöÑÂêéÁª≠ÁâáÊÆµ")
            }
            
        case .SS_Intro, .SS_Loop, .AP_Intro, .AP_Loop:
            print("üé¨ \(finishedClip.type) ÂÆåÊàê„ÄÇÁªßÁª≠Â∫èÂàó„ÄÇ")
            return
            
        default:
            print("‚ö†Ô∏è Êú™Â§ÑÁêÜÁöÑÁâáÊÆµÁ±ªÂûãÂÆåÊàê: \(finishedClip.type)„ÄÇ‰ΩøÁî®ÈöèÊú∫ AS ÈáçÊñ∞ÂºÄÂßã„ÄÇ")
            nextQueue = generateFallbackSequence()
            bpCycleCount = 0
        }
        
        if !nextQueue.isEmpty {
            print("‚úÖ ÁîüÊàêÊñ∞ÈòüÂàóÔºåÂåÖÂê´ \(nextQueue.count) ‰∏™ÁâáÊÆµ„ÄÇ")
            self.currentClipsQueue = nextQueue
            self.currentClipIndex = -1
        } else if finishedClip.type != .ST_Hide && finishedClip.type != .ST_Reveal
                    && finishedClip.type != .RPH && finishedClip.type != .SS_Outro
                    && finishedClip.type != .SS_Intro && finishedClip.type != .SS_Loop
                    && finishedClip.type != .AP_Intro && finishedClip.type != .AP_Loop
        {
            print(
                "‚ùå Êó†Ê≥ï‰∏∫ \(finishedClip.fileName) ÁîüÊàê‰∏ã‰∏Ä‰∏™Â∫èÂàó„ÄÇÂ§ÑÁêÜÈòüÂàóÁªìÊùü„ÄÇ"
            )
            handleEndOfQueue()
        }
    }
    
    private func handleEndOfQueue() {
        print(
            "‚ùå ÊÑèÂ§ñÂà∞ËææÈòüÂàóÊú´Â∞æÊàñÂ∫èÂàóÁîüÊàêÂ§±Ë¥•„ÄÇÂõûÈÄÄÂà∞ÈöèÊú∫ BP_Node„ÄÇ"
        )
        queuePlayer?.pause()
        queuePlayer?.removeAllItems()
        let fallbackQueue = generateFallbackSequence()
        if !fallbackQueue.isEmpty {
            self.currentClipsQueue = fallbackQueue
            self.currentClipIndex = 0
            playNextClipInQueue()
        } else {
            print("‚ùå ‰∏•ÈáçÈîôËØØÔºöÊó†Ê≥ïÁîüÊàêÂõûÈÄÄÈòüÂàóÔºÅÂÅúÊ≠¢Êí≠Êîæ„ÄÇ")
        }
    }
    
    // MARK: - Sequence Generation Helpers
    
    private func generateASSequence(fromNode: String? = nil) -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        var transitionNumber: String? = nil
        
        if let nodeName = fromNode {
            let bpToRphCandidates = allClips.filter { clip in
                guard clip.type == .BP_To, clip.to?.starts(with: "RPH") ?? false else {
                    return false
                }
                let pattern = "_BP\(nodeName.suffix(3))_To_"
                return clip.fileName.contains(pattern)
            }
            
            if let bpToRph = bpToRphCandidates.randomElement() {
                print("  Prepending BP_To_RPH: \(bpToRph.fileName) to AS sequence.")
                sequence.append(bpToRph)
            } else {
                print(
                    "‚ö†Ô∏è Warning: Could not find BP_To_RPH for node \(nodeName) to prepend to AS sequence."
                )
            }
        }
        
        guard let randomTMReveal = findRandomClip(ofType: .TM_Reveal) else {
            print("‚ùå Error: Could not find random TM_Reveal for AS sequence.")
            return generateFallbackSequence()
        }
        transitionNumber = randomTMReveal.number
        print(
            "  Selected TM_Reveal: \(randomTMReveal.fileName) (Number: \(transitionNumber ?? "nil"))"
        )
        
        guard let matchingSTReveal = findMatchingST(for: randomTMReveal, type: .ST_Reveal) else {
            print(
                "‚ùå Error: Could not find matching ST_Reveal for TM number \(transitionNumber ?? "nil")."
            )
            return generateFallbackSequence()
        }
        print("  Selected ST_Reveal: \(matchingSTReveal.fileName)")
        
        guard let randomAS = findRandomClip(ofType: .AS) else {
            print("‚ùå Error: Could not find random AS clip.")
            return generateFallbackSequence()
        }
        print("  Selected AS: \(randomAS.fileName)")
        
        // Âú®Ê≠§Â≠òÂÇ®ËΩ¨Âú∫ÁºñÂè∑Ôºå‰ª•‰æøASÊí≠ÊîæÂÆåÊàêÂêéÂèØ‰ª•ÊâæÂà∞ÂåπÈÖçÁöÑTM_Hide
        self.lastTransitionNumber = transitionNumber
        print("üíæ Stored lastTransitionNumber: \(self.lastTransitionNumber ?? "nil")")
        
        // ÊâæÂà∞ÂåπÈÖçÁöÑTM_HideÔºå‰ΩÜ‰∏çÂä†ÂÖ•Â∫èÂàó - ËøôÂ∞ÜÂú®ASÊí≠ÊîæÂÆåÊàêÊó∂‰ΩøÁî®
        guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber)
        else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫ \(transitionNumber ?? "any") ÁöÑ TM_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found TM_Hide: \(tmHide.fileName) - Â∞ÜÂú®ASÂÆåÊàêÂêé‰ΩøÁî®")
        
        guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÂåπÈÖç TM \(tmHide.number ?? "") ÁöÑ ST_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found ST_Hide: \(stHide.fileName) - Â∞ÜÂú®TM_HideÂÆåÊàêÂêé‰ΩøÁî®")
        
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÈöèÊú∫ RPH")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print(
                "‚ùå Guard Failed: Êâæ‰∏çÂà∞ RPH \(randomRPH.fileName) ÊåáÂêëÁöÑ BP ËäÇÁÇπ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
        
        // ÂÖ≥ÈîÆ‰øÆÊîπ: Â∫èÂàó‰∏≠Âè™ÂåÖÂê´ST_Reveal, TM_RevealÂíåAS
        // ÂÖ∂‰ªñÈÉ®ÂàÜ(TM_Hide, ST_Hide, RPH, BP_Node)Â∞ÜÂú®ASÊí≠ÊîæÂÆåÊàêÂêéÂçïÁã¨Â§ÑÁêÜ
        sequence += [matchingSTReveal, randomTMReveal, randomAS]
        
        // ‰∏∫ÂêéÁª≠‰ΩøÁî®Â≠òÂÇ®ÈúÄË¶ÅÊí≠ÊîæÁöÑÈÉ®ÂàÜ
        nextAfterAS = [tmHide, stHide, randomRPH, targetBPNode]
        
        print(
            "‚úÖ Generated AS sequence with \(sequence.count) clips. Stored \(nextAfterAS.count) clips for after AS."
        )
        return sequence
    }
    
    private func generateBP001ASSequence() -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        let fixedTransitionNumber: String = "006"  // Âõ∫ÂÆö‰ΩøÁî®006ÁºñÂè∑
        
        print("üéØ ÁîüÊàêBP001‰∏ìÁî®ASÂ∫èÂàóÔºå‰ΩøÁî®Âõ∫ÂÆöËΩ¨Âú∫ÁºñÂè∑: \(fixedTransitionNumber)")
        
        // ÊâæÂà∞ÁºñÂè∑‰∏∫006ÁöÑTM_Reveal
        guard let tmReveal006 = findRandomClip(ofType: .TM_Reveal, matchingNumber: fixedTransitionNumber) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫006ÁöÑTM_Reveal")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞TM_Reveal: \(tmReveal006.fileName)")
        
        // ÈöèÊú∫ÈÄâÊã©ASÁâáÊÆµ
        guard let randomAS = findRandomClip(ofType: .AS) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞ASÁâáÊÆµ")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞AS: \(randomAS.fileName)")
        
        // Â≠òÂÇ®ËΩ¨Âú∫ÁºñÂè∑ÔºåÁî®‰∫éASÊí≠ÊîæÂÆåÊàêÂêéÊâæÂà∞ÂåπÈÖçÁöÑTM_Hide
        self.lastTransitionNumber = fixedTransitionNumber
        print("üíæ Â≠òÂÇ®ËΩ¨Âú∫ÁºñÂè∑: \(self.lastTransitionNumber ?? "nil")")
        
        // ÊâæÂà∞ÁºñÂè∑‰∏∫006ÁöÑTM_Hide
        guard let tmHide006 = findRandomClip(ofType: .TM_Hide, matchingNumber: fixedTransitionNumber) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫006ÁöÑTM_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞TM_Hide: \(tmHide006.fileName)")
        
        // ÊâæÂà∞ÂåπÈÖçÁöÑST_Hide (AÊàñBÂèò‰Ωì)
        guard let stHide = findMatchingST(for: tmHide006, type: .ST_Hide) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞ÂåπÈÖç006ÁºñÂè∑ÁöÑST_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞ST_Hide: \(stHide.fileName) (Âèò‰Ωì: \(stHide.variant ?? "default"))")
        
        // ÈöèÊú∫ÈÄâÊã©RPH
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞RPHÁâáÊÆµ")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        // ÊâæÂà∞ÁõÆÊ†áBPËäÇÁÇπ
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print("‚ùå Error: Êâæ‰∏çÂà∞RPHÊåáÂêëÁöÑBPËäÇÁÇπ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("‚úÖ ÊâæÂà∞ÁõÆÊ†áBPËäÇÁÇπ: \(targetBPNode.fileName)")
        
        // ÊûÑÂª∫Â∫èÂàó TM_Reveal -> AS
        sequence = [tmReveal006, randomAS]
        
        // Â≠òÂÇ®ÂêéÁª≠ÁâáÊÆµÔºöTM_Hide -> ST_Hide -> RPH -> BP_Node
        nextAfterAS = [tmHide006, stHide, randomRPH, targetBPNode]
        
        print("üéØ BP001 ASÂ∫èÂàóÁîüÊàêÂÆåÊàê: \(sequence.count)‰∏™ÁâáÊÆµÔºåÂêéÁª≠\(nextAfterAS.count)‰∏™ÁâáÊÆµ")
        print("  Â∫èÂàó: \(sequence.map { $0.fileName }.joined(separator: " -> "))")
        print("  ÂêéÁª≠: \(nextAfterAS.map { $0.fileName }.joined(separator: " -> "))")
        
        return sequence
    }
    
    private func generateSSSequenceNew(fromNode: String? = nil) -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        let transitionNumber: String? = "001"
        
        if let nodeName = fromNode {
            let bpToRphCandidates = allClips.filter { clip in
                guard clip.type == .BP_To, clip.to?.starts(with: "RPH") ?? false else {
                    return false
                }
                let pattern = "_BP\(nodeName.suffix(3))_To_"
                return clip.fileName.contains(pattern)
            }
            
            if let bpToRph = bpToRphCandidates.randomElement() {
                print("  Prepending BP_To_RPH: \(bpToRph.fileName) to SS sequence.")
                sequence.append(bpToRph)
            } else {
                print(
                    "‚ö†Ô∏è Warning: Could not find BP_To_RPH for node \(nodeName) to prepend to SS sequence."
                )
            }
        }
        
        // ÂÖàÊâæÂà∞ÈúÄË¶ÅÁöÑST_RevealÂØπÂ∫îÁöÑ"001"ÁºñÂè∑
        guard let matchingSTReveal = findMatchingST(forNumber: transitionNumber, type: .ST_Reveal)
        else {
            print(
                "‚ùå Error: Could not find matching ST_Reveal for TM number \(transitionNumber ?? "nil")."
            )
            return generateFallbackSequence()
        }
        print("  Selected ST_Reveal: \(matchingSTReveal.fileName)")
        
        // ÊâæÂà∞SSÂ∫èÂàóÁöÑ‰∏âÈÉ®ÂàÜÔºöIntro, Loop, Outro
        guard let ssIntro = findRandomClip(ofType: .SS_Intro) else {
            print("‚ùå Error: Could not find random ssIntro.")
            return generateFallbackSequence()
        }
        print("  Selected ssIntro: \(ssIntro.fileName)")
        
        guard let ssLoop = findRandomClip(ofType: .SS_Loop) else {
            print("‚ùå Error: Could not find random ssLoop.")
            return generateFallbackSequence()
        }
        print("  Selected ssLoop: \(ssLoop.fileName)")
        
        guard let ssOutro = findRandomClip(ofType: .SS_Outro) else {
            print("‚ùå Error: Could not find random ssOutro.")
            return generateFallbackSequence()
        }
        print("  Selected ssOutro: \(ssOutro.fileName)")
        
        // Â≠òÂÇ®ÁºñÂè∑ÔºåÁî®‰∫éÊâæÂà∞ÂåπÈÖçÁöÑTM_Hide
        self.lastTransitionNumber = transitionNumber
        print("üíæ Stored lastTransitionNumber: \(self.lastTransitionNumber ?? "nil")")
        
        print("üé¨ SS Â∫èÂàóÁîüÊàê„ÄÇËßÑÂàíSSÂÆåÊàêÂêéÁöÑHalftoneËøáÊ∏°„ÄÇ")
        
        // È¢ÑÂÖàÁîüÊàêSSÂÆåÊàêÂêéÈúÄË¶ÅÊí≠ÊîæÁöÑÁâáÊÆµÂ∫èÂàó
        guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber)
        else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÁºñÂè∑‰∏∫ \(transitionNumber ?? "any") ÁöÑ TM_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found TM_Hide: \(tmHide.fileName) - Â∞ÜÂú®SSÂÆåÊàêÂêé‰ΩøÁî®")
        
        guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÂåπÈÖç TM \(tmHide.number ?? "") ÁöÑ ST_Hide")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found ST_Hide: \(stHide.fileName) - Â∞ÜÂú®TM_HideÂÆåÊàêÂêé‰ΩøÁî®")
        
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("‚ùå Guard Failed: Êâæ‰∏çÂà∞ÈöèÊú∫ RPH")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print(
                "‚ùå Guard Failed: Êâæ‰∏çÂà∞ RPH \(randomRPH.fileName) ÊåáÂêëÁöÑ BP ËäÇÁÇπ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("‚úÖ Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
        
        // ÂΩìÂâçÂ∫èÂàóÂè™ÂåÖÊã¨ST_RevealÂíåSS‰∏âÈÉ®ÂàÜ
        sequence += [matchingSTReveal, ssIntro, ssLoop, ssOutro]
        
        // ‰∏∫ÂêéÁª≠‰ΩøÁî®Â≠òÂÇ®ÈúÄË¶ÅÊí≠ÊîæÁöÑÈÉ®ÂàÜ - ËøôÂ∞ÜÂú®SS_OutroÊí≠ÊîæÂÆåÊàêÂêéÁöÑÂª∂ËøüÁªìÊùüÊó∂‰ΩøÁî®
        nextAfterAS = [tmHide, stHide, randomRPH, targetBPNode]
        
        print(
            "‚úÖ Generated SS sequence with \(sequence.count) clips. Stored \(nextAfterAS.count) clips for after SS_Outro."
        )
        return sequence
    }
    
    private func generateFallbackSequence() -> [SnoopyClip] {
        print("‚ö†Ô∏è ÁîüÊàêÂõûÈÄÄÂ∫èÂàó (ÈöèÊú∫ BP_Node)„ÄÇ")
        guard let randomBPNode = findRandomClip(ofType: .BP_Node) else {
            print("‚ùå ‰∏•ÈáçÈîôËØØÔºöÊó†Ê≥ïÊâæÂà∞‰ªª‰Ωï BP_Node ÁâáÊÆµËøõË°åÂõûÈÄÄÔºÅ")
            return []
        }
        bpCycleCount = 0
        lastTransitionNumber = nil
        currentNode = randomBPNode.node
        print("  ÂõûÈÄÄÂà∞: \(randomBPNode.fileName)")
        return [randomBPNode]
    }
    
    // MARK: - Clip Finding Helpers
    
    private func findClip(byFileName fileName: String) -> SnoopyClip? {
        return allClips.first { $0.fileName == fileName }
    }
    
    private func findClip(
        ofType type: SnoopyClip.ClipType, nodeName: String? = nil, groupID: String? = nil
    ) -> SnoopyClip? {
        return allClips.first { clip in
            var match = clip.type == type
            if let targetNodeName = nodeName {
                match =
                match
                && (clip.node == targetNodeName || clip.from == targetNodeName
                    || clip.to == targetNodeName)
            }
            if let group = groupID {
                match = match && clip.groupID == group
            }
            return match
        }
    }
    
    private func findRandomClip(ofType type: SnoopyClip.ClipType, matchingNumber: String? = nil)
    -> SnoopyClip?
    {
        let candidates = allClips.filter { $0.type == type }
        
        // Add debugging for TM clips
        if type == .TM_Hide || type == .TM_Reveal {
            print("üîç Debug TM clips:")
            for clip in candidates {
                print("  - \(clip.fileName) (number: \(clip.number ?? "nil"))")
            }
        }
        
        if let number = matchingNumber {
            let filteredByNumber = candidates.filter { $0.number == number }
            if !filteredByNumber.isEmpty {
                print("üîç ÊâæÂà∞ÂåπÈÖçÁºñÂè∑ \(number) ÁöÑ \(type) ÁâáÊÆµ„ÄÇ")
                return filteredByNumber.randomElement()
            } else {
                print("‚ö†Ô∏è Ë≠¶Âëä: Êú™ÊâæÂà∞ÁºñÂè∑‰∏∫ \(number) ÁöÑ \(type) ÁâáÊÆµÔºåÂ∞ÜÈöèÊú∫ÈÄâÊã©„ÄÇ")
                print("üîç Available candidates: \(candidates.map { "\($0.fileName)(num:\($0.number ?? "nil"))" })")
                
                // ÂØπ‰∫éTMÁ±ªÂûãÔºåÈöèÊú∫ÈÄâÊã©Êó∂ÊéíÈô§006ÁºñÂè∑
                if type == .TM_Hide || type == .TM_Reveal {
                    let filteredCandidates = candidates.filter { $0.number != "006" }
                    if !filteredCandidates.isEmpty {
                        print("üîç ÊéíÈô§006ÁºñÂè∑ÂêéÔºå‰ªé \(filteredCandidates.count) ‰∏™ÂÄôÈÄâ‰∏≠ÈöèÊú∫ÈÄâÊã©")
                        return filteredCandidates.randomElement()
                    } else {
                        print("‚ö†Ô∏è ÊéíÈô§006ÂêéÊ≤°ÊúâÂèØÁî®ÁöÑTMÁâáÊÆµÔºå‰ΩøÁî®ÂéüÂßãÂÄôÈÄâ")
                        return candidates.randomElement()
                    }
                } else {
                    return candidates.randomElement()
                }
            }
        } else {
            // ÂØπ‰∫éTMÁ±ªÂûãÔºåÈöèÊú∫ÈÄâÊã©Êó∂ÊéíÈô§006ÁºñÂè∑
            if type == .TM_Hide || type == .TM_Reveal {
                let filteredCandidates = candidates.filter { $0.number != "006" }
                if !filteredCandidates.isEmpty {
                    print("üîç ÊéíÈô§006ÁºñÂè∑ÂêéÔºå‰ªé \(filteredCandidates.count) ‰∏™TMÂÄôÈÄâ‰∏≠ÈöèÊú∫ÈÄâÊã©")
                    return filteredCandidates.randomElement()
                } else {
                    print("‚ö†Ô∏è ÊéíÈô§006ÂêéÊ≤°ÊúâÂèØÁî®ÁöÑTMÁâáÊÆµÔºå‰ΩøÁî®ÂéüÂßãÂÄôÈÄâ")
                    return candidates.randomElement()
                }
            } else {
                return candidates.randomElement()
            }
        }
    }
    
    private func findMatchingST(
        for tmClip: SnoopyClip? = nil, forNumber number: String? = nil, type: SnoopyClip.ClipType
    ) -> SnoopyClip? {
        guard type == .ST_Hide || type == .ST_Reveal else { return nil }
        let targetNumber = tmClip?.number ?? number
        guard let num = targetNumber else { return nil }
        
        let matchingSTs = allClips.filter { $0.type == type && $0.number == num }
        
        if matchingSTs.isEmpty {
            print("‚ö†Ô∏è Ë≠¶ÂëäÔºöÊú™ÊâæÂà∞ÂåπÈÖçÁöÑ \(type) ÁâáÊÆµÔºåÁºñÂè∑‰∏∫ \(num)")
            return nil
        }
        
        let variants = matchingSTs.filter { $0.variant != nil }
        if !variants.isEmpty {
            return variants.randomElement()
        } else {
            return matchingSTs.first
        }
    }
    
    private func findClipForPlayerItem(_ item: AVPlayerItem) -> SnoopyClip? {
        guard let url = (item.asset as? AVURLAsset)?.url else { return nil }
        return allClips.first { clip in
            if let clipUrl = Bundle(for: type(of: self)).url(
                forResource: clip.fileName, withExtension: nil)
            {
                return clipUrl == url
            }
            return false
        }
    
    // MARK: - Background Update Functions
    
    private func updateBackgrounds() {
            print("üîÑ Êõ¥Êñ∞ËÉåÊôØ...")
            
            // Ê£ÄÊü•Âπ∂Á°Æ‰øùÂçäËâ≤Ë∞ÉÂ±ÇÂèØËßÅ
            if let halftoneNode = self.halftoneNode {
                halftoneNode.alpha = 0.3  // ËÆæÁΩÆÈÄÇÂΩìÁöÑÈÄèÊòéÂ∫¶
            }
            
            updateBackgroundColor()
            updateBackgroundImage()
        }
        
        private func updateBackgroundColor() {
            guard let bgNode = self.backgroundColorNode else { return }
            let randomColor = colors.randomElement() ?? .black
            bgNode.color = randomColor
            bgNode.alpha = 1  // ÊòæÁ§∫ËÉåÊôØÈ¢úËâ≤
            print("üé® ËÉåÊôØÈ¢úËâ≤Êõ¥Êñ∞‰∏∫: \(randomColor)")
        }
        
        private func updateBackgroundImage() {
            guard let imageNode = self.backgroundImageNode, !backgroundImages.isEmpty else { return }
            
            let randomImageName = backgroundImages.randomElement()!
            guard
                let imagePath = Bundle(for: type(of: self)).path(
                    forResource: randomImageName, ofType: nil),
                let image = NSImage(contentsOfFile: imagePath)
            else {
                print("‚ùå Êó†Ê≥ïÂä†ËΩΩËÉåÊôØÂõæÁâá: \(randomImageName)")
                return
            }
            
            let texture = SKTexture(image: image)
            imageNode.texture = texture
            
            guard let scene = self.scene else { return }
            
            let imageAspect = image.size.height / scene.size.height
            guard imageAspect > 0 else {
                print("‚ùå ÈîôËØØ: IS ÂõæÁâáÈ´òÂ∫¶ÊàñÂú∫ÊôØÈ´òÂ∫¶‰∏∫Èõ∂ÔºåÊó†Ê≥ïËÆ°ÁÆó imageAspect„ÄÇ")
                return
            }
            imageNode.size = CGSize(
                width: image.size.width / imageAspect * scale,
                height: scene.size.height * scale)
            imageNode.position = CGPoint(
                x: scene.size.width / 2,
                y: scene.size.height / 2 - scene.size.height * offside)
            imageNode.alpha = 1  // ÊòæÁ§∫ËÉåÊôØÂõæÁâá
            
            print("üñºÔ∏è ËÉåÊôØÂõæÁâáÊõ¥Êñ∞‰∏∫: \(randomImageName)")
        }
        
        // MARK: - Overlay (VI/WE) Functions
        
        private func tryPlayVIWEOverlay() {
            guard overlayPlayerItem == nil else {
                print("üö´ Âè†Âä†Â±ÇÂ∑≤Âú®Êí≠ÊîæÔºåË∑≥ËøáÊñ∞ÁöÑËß¶Âèë„ÄÇ")
                return
            }
            
            let viClips = allClips.filter { $0.type == .VI_Single || $0.type == .VI_Intro }
            let weClips = allClips.filter { $0.type == .WE_Single || $0.type == .WE_Intro }
            let candidates = viClips + weClips
            
            guard let clipToPlay = candidates.randomElement() else {
                print("ü§∑ Ê≤°ÊúâÂèØÁî®ÁöÑ VI/WE ÁâáÊÆµÂèØ‰æõÊí≠Êîæ„ÄÇ")
                return
            }
            
            print("‚ú® Ëß¶ÂèëÂè†Âä†ÊïàÊûú: \(clipToPlay.fileName)")
            playOverlayClip(clipToPlay)
        }
        
        private func playOverlayClip(_ clip: SnoopyClip) {
            guard
                let url = Bundle(for: type(of: self)).url(
                    forResource: clip.fileName, withExtension: nil)
            else {
                print("‚ùå ÈîôËØØÔºöÊâæ‰∏çÂà∞Âè†Âä†ÁâáÊÆµÊñá‰ª∂ \(clip.fileName)")
                cleanupOverlay()
                return
            }
            
            let newItem = AVPlayerItem(url: url)
            self.overlayPlayerItem = newItem
            
            // ‰∏çÂÜçÈúÄË¶ÅËÆæÁΩÆoverlayRepeatCountÔºåLoopÁöÑÁªßÁª≠Áî±‰∏ªÂ∫èÂàóÁä∂ÊÄÅÂÜ≥ÂÆö
            self.overlayRepeatCount = 0
            print("üìΩÔ∏è Êí≠ÊîæÂè†Âä†ÁâáÊÆµ: \(clip.fileName)ÔºåLoopÊéßÂà∂Áî±‰∏ªÂ∫èÂàóÁä∂ÊÄÅÂÜ≥ÂÆö")
            
            overlayPlayer?.removeAllItems()
            overlayPlayer?.insert(newItem, after: nil)
            overlayNode?.isHidden = false
            overlayPlayer?.play()
            print("‚ñ∂Ô∏è Êí≠ÊîæÂè†Âä†ÁâáÊÆµ: \(clip.fileName)")
        }
        
        private func cleanupOverlay() {
            print("üßπ Ê∏ÖÁêÜÂè†Âä†Â±Ç„ÄÇ")
            overlayPlayer?.pause()
            overlayPlayer?.removeAllItems()
            overlayPlayerItem = nil
            overlayNode?.isHidden = true
            overlayRepeatCount = 0
        }
        
        private func isCurrentlyInBPCycle() -> Bool {
            // Ê£ÄÊü•‰∏ªÂ∫èÂàóÊòØÂê¶‰ªçÂú®BPÂæ™ÁéØÁä∂ÊÄÅ‰∏≠
            let isBPLooping = (currentStateType == .playingBP || currentStateType == .playingAPLoop)
            
            // È¢ùÂ§ñÊ£ÄÊü•ÔºöÂ¶ÇÊûúÂΩìÂâçÈòüÂàó‰∏≠ÂåÖÂê´Ê≠£Âú®Âæ™ÁéØÁöÑBP_NodeÊàñAP_Loop
            let hasLoopingClip = currentClipIndex < currentClipsQueue.count &&
            (currentClipsQueue[currentClipIndex].type == .BP_Node ||
             currentClipsQueue[currentClipIndex].type == .AP_Loop) &&
            currentRepeatCount > 0
            
            let result = isBPLooping || hasLoopingClip
            print("üîç isCurrentlyInBPCycle: \(result) (Áä∂ÊÄÅ: \(currentStateType), ÈáçÂ§çÊ¨°Êï∞: \(currentRepeatCount))")
            return result
        }
        
        private func handleOverlayItemFinish(finishedItem: AVPlayerItem) {
            print("‚úÖ Âè†Âä†ÁâáÊÆµÊí≠ÊîæÂÆåÊàê„ÄÇ")
            
            var lastPlayedClip: SnoopyClip? = nil
            if let finishedUrl = (finishedItem.asset as? AVURLAsset)?.url {
                lastPlayedClip = allClips.first(where: { clip in
                    if let clipUrl = Bundle(for: type(of: self)).url(
                        forResource: clip.fileName, withExtension: nil)
                    {
                        return clipUrl == finishedUrl
                    }
                    return false
                })
            }
            
            guard let finishedClip = lastPlayedClip else {
                print("‚ùå Êó†Ê≥ïÊâæÂà∞ÂÆåÊàêÁöÑÂè†Âä†È°πÁõÆÁöÑ SnoopyClip„ÄÇÊ∏ÖÁêÜ„ÄÇ")
                cleanupOverlay()
                return
            }
            
            print("üîç ÂÆåÊàêÁöÑoverlayÁâáÊÆµ: \(finishedClip.fileName) (Á±ªÂûã: \(finishedClip.type), groupID: \(finishedClip.groupID ?? "nil"))")
            print("üîç ‰∏ªÂ∫èÂàóÁä∂ÊÄÅ: \(currentStateType)")
            
            var nextOverlayClip: SnoopyClip? = nil
            let groupID = finishedClip.groupID
            
            if finishedClip.type == SnoopyClip.ClipType.VI_Intro
                || finishedClip.type == SnoopyClip.ClipType.WE_Intro
            {
                let loopType: SnoopyClip.ClipType =
                (finishedClip.type == .VI_Intro) ? .VI_Loop : .WE_Loop
                nextOverlayClip = findClip(ofType: loopType, groupID: groupID)
                if let nextClip = nextOverlayClip {
                    print("‚úÖ Âè†Âä† Intro ÂÆåÊàêÔºåÈòüÂàó Loop: \(nextClip.fileName)")
                } else {
                    print(
                        "‚ùå Âè†Âä† Intro ÂÆåÊàêÔºå‰ΩÜÊú™ÊâæÂà∞ÁªÑ \(groupID ?? "nil") ÁöÑ Loop„ÄÇÊ∏ÖÁêÜ„ÄÇ"
                    )
                }
            } else if finishedClip.type == SnoopyClip.ClipType.VI_Loop
                        || finishedClip.type == SnoopyClip.ClipType.WE_Loop
            {
                // Ê£ÄÊü•‰∏ªÂ∫èÂàóÊòØÂê¶‰ªçÂú®BPÂæ™ÁéØ‰∏≠ÔºåËÄå‰∏çÊòØ‰ΩøÁî®overlayRepeatCount
                if isCurrentlyInBPCycle() {
                    // ‰∏ªÂ∫èÂàó‰ªçÂú®BPÂæ™ÁéØ‰∏≠ÔºåÁªßÁª≠Êí≠ÊîæLoop
                    nextOverlayClip = finishedClip
                    print("üîÅ Âè†Âä† Loop ÂÆåÊàêÔºå‰∏ªÂ∫èÂàó‰ªçÂú®BPÂæ™ÁéØ‰∏≠ÔºåÁªßÁª≠Êí≠ÊîæLoop")
                } else {
                    // ‰∏ªÂ∫èÂàóÂ∑≤ÈÄÄÂá∫BPÂæ™ÁéØÔºåÂº∫Âà∂ËøõÂÖ•Outro
                    let outroType: SnoopyClip.ClipType =
                    (finishedClip.type == .VI_Loop) ? .VI_Outro : .WE_Outro
                    nextOverlayClip = findClip(ofType: outroType, groupID: groupID)
                    print(
                        "‚úÖ Âè†Âä† Loop ÂÆåÊàêÔºå‰∏ªÂ∫èÂàóÂ∑≤ÈÄÄÂá∫BPÂæ™ÁéØÔºåÂº∫Âà∂ËøõÂÖ•Outro: \(nextOverlayClip?.fileName ?? "Êú™ÊâæÂà∞")"
                    )
                }
            }
            
            if let nextClip = nextOverlayClip {
                playOverlayClip(nextClip)
            } else {
                print(
                    "‚úÖ Âè†Âä†Â∫èÂàóÂÆåÊàêÊàñÊú™ÊâæÂà∞ÁªÑ \(groupID ?? "nil") ÁöÑ‰∏ã‰∏Ä‰∏™ÁâáÊÆµ„ÄÇÊ∏ÖÁêÜ„ÄÇ"
                )
                cleanupOverlay()
            }
        }
        
        private func interruptOverlayLoopAndPlayOutro(groupID: String) {
            print("üí• ËØ∑Ê±Ç‰∏≠Êñ≠overlay LoopÔºågroupID: \(groupID)")
            
            let outroType: SnoopyClip.ClipType?
            if findClip(ofType: .VI_Loop, groupID: groupID) != nil {
                outroType = .VI_Outro
            } else if findClip(ofType: .WE_Loop, groupID: groupID) != nil {
                outroType = .WE_Outro
            } else {
                outroType = nil
            }
            
            guard let type = outroType, let outroClip = findClip(ofType: type, groupID: groupID) else {
                print("‚ö†Ô∏è Êó†Ê≥ïÊâæÂà∞ÁªÑ \(groupID) ÁöÑ Outro Êù•ÊâìÊñ≠ Loop„ÄÇ")
                cleanupOverlay()
                return
            }
            
            print("üí• ÊâìÊñ≠Âè†Âä† LoopÔºåÊí≠Êîæ Outro: \(outroClip.fileName)")
            overlayRepeatCount = 0  // ÈáçÁΩÆÈáçÂ§çËÆ°Êï∞ÔºåÂº∫Âà∂ÁªìÊùüLoop
            playOverlayClip(outroClip)
        }
        
        // MARK: - Masking Functions
        
        private func startMaskTransitionWithHEIC(basePattern: String, tmClip: SnoopyClip, contentClip: SnoopyClip?, isRevealing: Bool) {
            print("üé≠ ÂºÄÂßãHEICÈÅÆÁΩ©ËøáÊ∏°: \(basePattern), TMÁâáÊÆµ: \(tmClip.fileName), ÊòæÁ§∫: \(isRevealing)")
            guard let scene = self.scene else {
                print("‚ùå ÈîôËØØÔºöHEICÈÅÆÁΩ©ËøáÊ∏°Áº∫Â∞ëÂú∫ÊôØÁªÑ‰ª∂„ÄÇ")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            isMasking = true
            
            // ÂàõÂª∫mask sprite nodeÂ¶ÇÊûú‰∏çÂ≠òÂú®
            if self.tmMaskSpriteNode == nil {
                let maskNode = SKSpriteNode(color: .clear, size: scene.size)
                maskNode.position = .zero  // Áõ∏ÂØπ‰∫écropNodeÁöÑ‰ΩçÁΩÆ
                self.tmMaskSpriteNode = maskNode
            }
            
            guard let maskNode = self.tmMaskSpriteNode,
                  let asVideoNode = self.asVideoNode,  // Use AS video node instead of main video node
                  let heicPlayer = self.heicSequencePlayer
            else {
                print("‚ùå ÈîôËØØÔºöHEICÈÅÆÁΩ©ËøáÊ∏°Áº∫Â∞ëËßÜÈ¢ëËäÇÁÇπÁªÑ‰ª∂„ÄÇ")
                isMasking = false
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // ËÆæÁΩÆmaskNodeÂ∞∫ÂØ∏
            maskNode.size = scene.size
            maskNode.position = .zero  // Áõ∏ÂØπ‰∫écropNode
            
            // ÂàõÂª∫ÊàñÈáçÁî®cropNodeÊù•Â∫îÁî®ÈÅÆÁΩ©ÊïàÊûú
            guard let cropNode = self.cropNode else {
                print("‚ùå ÈîôËØØÔºöcropNodeÂ∫îËØ•Âú®ÂàùÂßãÂåñÊó∂Â∑≤ÂàõÂª∫")
                isMasking = false
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // cropNodeÂßãÁªà‰øùÊåÅÂú®zPosition=10Ôºå‰∏çÈúÄË¶ÅË∞ÉÊï¥Â±ÇÁ∫ß
            
            // ÁßªÈô§ÊóßÁöÑÂ≠êËäÇÁÇπÂíåÁà∂ËäÇÁÇπÂÖ≥Á≥ª - AS video node is already in cropNode
            // No need to move asVideoNode since it's already positioned correctly in cropNode
            
            // Â∞ÜmaskNodeËÆæÁΩÆ‰∏∫cropNodeÁöÑmask
            cropNode.maskNode = maskNode
            
            if isRevealing {
                // TM_Reveal: ÊòæÁ§∫AS/SS
                guard let contentClip = contentClip,
                      let contentUrl = Bundle(for: type(of: self)).url(
                        forResource: contentClip.fileName, withExtension: nil)
                else {
                    print("‚ùå ÈîôËØØÔºöHEICÊòæÁ§∫ËøáÊ∏°Áº∫Â∞ëÂÜÖÂÆπÁâáÊÆµ (AS/SS)„ÄÇ")
                    isMasking = false
                    currentClipIndex += 1
                    playNextClipInQueue()
                    return
                }
                
                print("üîÑ ÂáÜÂ§áÊòæÁ§∫ÂÜÖÂÆπ: \(contentClip.fileName)")
                
                // ‰∏∫AS/SSÂÜÖÂÆπÂáÜÂ§áÁã¨Á´ãÊí≠ÊîæÂô®
                let newItem = AVPlayerItem(url: contentUrl)
                self.asPlayerItem = newItem
                asPlayer?.replaceCurrentItem(with: newItem)
                asPlayer?.pause()  // ÊöÇÂÅúÁõ¥Âà∞ÈÅÆÁΩ©ÂÆåÊàê
                
                // Á°Æ‰øùASËßÜÈ¢ëËäÇÁÇπÂèØËßÅ
                asVideoNode.isHidden = false
                
                if contentClip.type == .AS {
                    // Êõ¥Êñ∞ÂΩìÂâçÁä∂ÊÄÅ
                    currentStateType = .playingTMReveal
                    // ‰ΩøÁî®TM_RevealÁöÑÁºñÂè∑ËÄå‰∏çÊòØASÁöÑÁºñÂè∑ÔºåÂõ†‰∏∫ASÈÄöÂ∏∏Ê≤°ÊúâÁºñÂè∑
                    self.lastTransitionNumber = tmClip.number  
                    print("üíæ TM_RevealËøáÊ∏°ÊúüÈó¥Â≠òÂÇ®ËΩ¨Âú∫ÁºñÂè∑: \(self.lastTransitionNumber ?? "nil")")
                } else if contentClip.type == .SS_Intro {
                    currentStateType = .playingSSIntro
                }
                
                // ÂºÄÂßãÊí≠ÊîæHEICÂ∫èÂàó
                heicPlayer.play(on: maskNode) { [weak self] in
                    DispatchQueue.main.async {
                        self?.heicSequenceMaskCompleted(isRevealing: true, tmClip: tmClip, basePattern: basePattern)
                    }
                }
            } else {
                // TM_Hide: ÈöêËóèÂΩìÂâçÂÜÖÂÆπ
                if self.currentStateType == .playingAS {
                    currentStateType = .transitioningToHalftoneHide
                }
                
                // Êí≠ÊîæHEICÂ∫èÂàó
                heicPlayer.play(on: maskNode) { [weak self] in
                    DispatchQueue.main.async {
                        self?.heicSequenceMaskCompleted(isRevealing: false, tmClip: tmClip, basePattern: basePattern)
                    }
                }
            }
        }
        
        private func heicSequenceMaskCompleted(isRevealing: Bool, tmClip: SnoopyClip, basePattern: String) {
            print("‚úÖ HEICÈÅÆÁΩ©Â∫èÂàóÂÆåÊàê: \(basePattern), ÊòæÁ§∫: \(isRevealing), TMÁâáÊÆµ: \(tmClip.fileName)")
            
            if isRevealing {
                // TM_RevealÂÆåÊàêÔºöÂºÄÂßãÊí≠ÊîæAS/SSÂÜÖÂÆπ
                print("‚ñ∂Ô∏è TM_RevealÂÆåÊàêÔºåÂºÄÂßãÊí≠ÊîæAS/SSÂÜÖÂÆπ")
                asPlayer?.play()  // Use AS player instead of queue player
                
                // Â¶ÇÊûúÂΩìÂâçÊí≠ÊîæÁöÑÊòØASÔºåÊ∏ÖÈô§ÈòüÂàó
                if currentStateType == .playingTMReveal && currentClipIndex + 1 < currentClipsQueue.count &&
                    currentClipsQueue[currentClipIndex + 1].type == .AS {
                    print("üîÑ ASÊòæÁ§∫ÔºåÊ∏ÖÁêÜÈòüÂàó")
                    currentClipIndex += 1  // ÁßªÂà∞AS
                }
            } else {
                // TM_HideÂÆåÊàêÔºöÈöêËóèAS/SSÂÜÖÂÆπÂπ∂ÁªßÁª≠Âà∞‰∏ã‰∏Ä‰∏™Â∫èÂàó
                print("‚ñ∂Ô∏è TM_HideÂÆåÊàêÔºåÈöêËóèAS/SSÂÜÖÂÆπÂπ∂ÁªßÁª≠Âà∞‰∏ã‰∏Ä‰∏™Â∫èÂàó")
                
                // ÈöêËóèASËßÜÈ¢ëËäÇÁÇπ
                if let asVideoNode = self.asVideoNode {
                    asVideoNode.isHidden = true
                }
                
                // ÊöÇÂÅúASÊí≠ÊîæÂô®
                asPlayer?.pause()
                
                // ‰ΩøÁî®ÂΩìÂâçTM_HideÁâáÊÆµÁöÑÁºñÂè∑Êù•ÁîüÊàêST_HideÂ∫èÂàó
                let transitionNumber = tmClip.number
                print("üîç ‰ΩøÁî®TM_HideÁºñÂè∑ÁîüÊàêÂ∫èÂàó: \(transitionNumber ?? "nil")")
                
                if !nextAfterAS.isEmpty {
                    print("üîÑ ‰ΩøÁî®È¢ÑÂ≠òÈòüÂàó: \(nextAfterAS.count) ÁâáÊÆµ")
                    
                    // Á°Æ‰øùnextAfterASÂåÖÂê´È¢ÑÊúüÁöÑST_Hide ‚Üí RPH ‚Üí BP_NodeÂ∫èÂàó
                    if nextAfterAS.count >= 3 && nextAfterAS[0].type == .ST_Hide {
                        print("‚úÖ Á°ÆËÆ§ÈòüÂàóÊ≠£Á°ÆÔºö‰∏ã‰∏Ä‰∏™ÁâáÊÆµÊòØST_Hide: \(nextAfterAS[0].fileName)")
                        
                        // ËÆæÁΩÆÂΩìÂâçÈòüÂàóÂπ∂‰ªéÁ¥¢Âºï0ÂºÄÂßãÔºàÂç≥ST_HideÔºâ
                        currentClipsQueue = nextAfterAS
                        currentClipIndex = 0
                        nextAfterAS = []
                        
                    } else {
                        print("‚ö†Ô∏è nextAfterASÈòüÂàó‰∏çÊ≠£Á°ÆÔºåÂ∞ùËØïÈáçÊñ∞ÁîüÊàêÊ≠£Á°ÆÁöÑÂ∫èÂàó")
                        
                        // ‰ΩøÁî®TM_HideÁöÑÁºñÂè∑ÈáçÊñ∞ÁîüÊàêÊ≠£Á°ÆÁöÑÂ∫èÂàó
                        if let number = transitionNumber,
                           let stHide = findMatchingST(forNumber: number, type: .ST_Hide),
                           let randomRPH = findRandomClip(ofType: .RPH),
                           let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) {
                            
                            // ÈáçÊñ∞ÂàõÂª∫Ê≠£Á°ÆÁöÑÈòüÂàó
                            currentClipsQueue = [stHide, randomRPH, targetBPNode]
                            currentClipIndex = 0
                            print("‚úÖ ÊàêÂäüÈáçÂª∫ÈòüÂàó: ST_Hide ‚Üí RPH ‚Üí BP_Node")
                        } else {
                            print("‚ùå Êó†Ê≥ïÁîüÊàêÊ≠£Á°ÆÁöÑST_HideÂ∫èÂàóÔºå‰ΩøÁî®ÂõûÈÄÄÂ∫èÂàó")
                            let fallbackQueue = generateFallbackSequence()
                            if !fallbackQueue.isEmpty {
                                currentClipsQueue = fallbackQueue
                                currentClipIndex = 0
                            }
                        }
                    }
                } else {
                    print("üîÑ Ê≤°ÊúâÈ¢ÑÂ≠òÈòüÂàóÔºåÂü∫‰∫éTM_HideÁºñÂè∑ÁîüÊàêST_Hide ‚Üí RPH ‚Üí BP_NodeÂ∫èÂàó")
                    
                    // Áõ¥Êé•‰ΩøÁî®TM_HideÁöÑÁºñÂè∑ÁîüÊàêST_HideÂ∫èÂàó
                    if let number = transitionNumber,
                       let stHide = findMatchingST(forNumber: number, type: .ST_Hide),
                       let randomRPH = findRandomClip(ofType: .RPH),
                       let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) {
                        
                        currentClipsQueue = [stHide, randomRPH, targetBPNode]
                        currentClipIndex = 0
                        print("‚úÖ Âü∫‰∫éTM_HideÁºñÂè∑ \(number) ÁîüÊàêÈòüÂàó: ST_Hide ‚Üí RPH ‚Üí BP_Node")
                    } else {
                        print("‚ùå Êó†Ê≥ïÂü∫‰∫éTM_HideÁºñÂè∑ÁîüÊàêÂ∫èÂàóÔºå‰ΩøÁî®ÂõûÈÄÄÂ∫èÂàó")
                        let fallbackQueue = generateFallbackSequence()
                        if !fallbackQueue.isEmpty {
                            currentClipsQueue = fallbackQueue
                            currentClipIndex = 0
                        }
                    }
                }
            }
            
            // Ê∏ÖÁêÜcropNodeÈÅÆÁΩ©ÊïàÊûú
            if let cropNode = self.cropNode {
                // Ê∏ÖÈô§ÈÅÆÁΩ©ÊïàÊûú
                cropNode.maskNode = nil
                print("üßπ Ê∏ÖÁêÜcropNodeÈÅÆÁΩ©ÊïàÊûú")
                
                // ASËßÜÈ¢ëËäÇÁÇπÂßãÁªà‰øùÊåÅÂú®cropNode‰∏≠Ôºå‰∏çÈúÄË¶ÅÁßªÂä®
                // cropNode will be reused for future AS/SS content with masking
            }
            
            // ÈáçÁΩÆÁä∂ÊÄÅ
            isMasking = false
            
            // ÁªßÁª≠ÈòüÂàóÂ§ÑÁêÜ
            playNextClipInQueue()
        }
        
        // Old AVPlayer-based mask transition removed - replaced by startMaskTransitionWithHEIC
        
        // TM mask playback is now handled by HEIC sequence player via heicSequenceMaskCompleted callback
        
        // Helper methods for TM management are now handled by HEIC sequence player
        
        // MARK: - ScreenSaverView Overrides & Lifecycle
        
        override func startAnimation() {
            super.startAnimation()
            queuePlayer?.play()
            asPlayer?.play()  // Start AS player if it has content
            if overlayPlayerItem != nil {
                overlayPlayer?.play()
            }
        }
        
        override func stopAnimation() {
            super.stopAnimation()
            queuePlayer?.pause()
            asPlayer?.pause()  // Pause AS player
            overlayPlayer?.pause()
        }
        
        override func draw(_ rect: NSRect) {
            super.draw(rect)
        }
        
        override func animateOneFrame() {
        }
        
        override var hasConfigureSheet: Bool {
            return false
        }
        
        override var configureSheet: NSWindow? {
            return nil
        }
        
        @objc static func isCompatibleWithModernScreenSaverEngine() -> Bool {
            return true
        }
        
        // MARK: - Notifications
        
        private func setNotifications() {
            DistributedNotificationCenter.default.addObserver(
                self,
                selector: #selector(willStop(_:)),
                name: Notification.Name("com.apple.screensaver.willstop"),
                object: nil
            )
            
            DistributedNotificationCenter.default.addObserver(
                self,
                selector: #selector(willStart(_:)),
                name: Notification.Name("com.apple.screensaver.willstart"),
                object: nil
            )
            
            NSWorkspace.shared.notificationCenter.addObserver(
                self,
                selector: #selector(onSleepNote(note:)),
                name: NSWorkspace.willSleepNotification,
                object: nil
            )
        }
        
        @objc private func willStop(_ notification: Notification) {
            print("Â±è‰øùÂ∞ÜË¶ÅÂÅúÊ≠¢")
            
            if #available(macOS 14.0, *) {
                DispatchQueue.main.async {
                    exit(0)
                }
            }
            
            stopAnimation()
        }
        
        @objc private func willStart(_ notification: Notification) {
            print("Â±è‰øùÂ∞ÜË¶ÅÂºÄÂßã")
        }
        
        @objc private func onSleepNote(note: Notification) {
            print("Á≥ªÁªüÂ∞ÜË¶ÅÁù°Áú†")
            
            if #available(macOS 14.0, *) {
                DispatchQueue.main.async {
                    exit(0)
                }
            }
        }
        
        deinit {
            NotificationCenter.default.removeObserver(self)
            DistributedNotificationCenter.default.removeObserver(self)
            NSWorkspace.shared.notificationCenter.removeObserver(self)
            // observeMaskPlayerItem removed - no longer needed for HEIC sequence player
            
            queuePlayer?.pause()
            queuePlayer = nil
            overlayPlayer?.pause()
            overlayPlayer = nil
            // tmMaskPlayer removed - now using HEIC sequence player for TM animations
        }
    }
}

// MARK: - Array Extension

extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
